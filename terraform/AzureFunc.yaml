Pipeline.yml
trigger:
  branches:
    exclude:
      - '*'

name: 1.0.$(Year:yy)$(DayOfYear).$(rev:r)

pool:
  name: 'eheu2pd1epvmss'

variables:
  buildConfiguration: Release
  VSTS_ARM_REST_IGNORE_SSL_ERRORS: true
  system.debug: false
stages:
  - stage: Build
    jobs:
      - job: Test
        steps:
          - task: UseDotNet@2
            displayName: 'Install .NET Core SDK'
            inputs:
              version: 8.x
              performMultiLevelLookup: true
              includePreviewVersions: false
          - task: DotNetCoreCLI@2
            displayName: dotnet restore
            inputs:
              command: 'restore'
              feedsToUse: 'config'
              nugetConfigPath: 'NuGet.Config'
          - task: DotNetCoreCLI@2
            displayName: dotnet build
            inputs:
              command: 'build'
              feedsToUse: 'config'
              nugetConfigPath: 'NuGet.Config'
          - task: DotNetCoreCLI@2
            displayName: dotnet test
            inputs:
              command: 'test'
              feedsToUse: 'config'
              nugetConfigPath: 'NuGet.Config'
      - job: BuildOcrRetryFunction
        workspace:
          clean: all
        steps:
          - task: UseDotNet@2
            displayName: 'Install .NET 8 SDK'
            inputs:
              packageType: 'sdk'
              version: '8.0.x'
              performMultiLevelLookup: true
          - task: NuGetAuthenticate@1
          - task: DotNetCoreCLI@2
            displayName: nuget Restore
            inputs:
              command: restore
              feedsToUse: select
              vstsFeed: 5483129a-4405-40c1-8ccb-a688120b3137
              projects: '**/*.csproj'
          - task: DotNetCoreCLI@2
            displayName: Compile function
            inputs:
              command: build
              projects: '**/*Function.OcrRetry.csproj'
          - task: DotNetCoreCLI@2
            displayName: Publish .net 8
            inputs:
              command: publish
              publishWebProjects: false
              projects: '**/UCX.ACLService.Function.OcrRetry/*.csproj'
              arguments: >-
                --configuration $(buildConfiguration) --output
                $(Build.ArtifactStagingDirectory)/OcrRetryFunction
              zipAfterPublish: true
          - task: PublishBuildArtifacts@1
            displayName: Publish Package
            inputs:
              PathtoPublish: $(Build.ArtifactStagingDirectory)
              ArtifactName: BuildArtifacts
  - stage: DV1Infrastructure
    displayName: "Create infrastructure for DV1 Ocr Retry Function"
    dependsOn: [ ]
    jobs:
      - template: ./ocr-retry-function-pipeline-Infrastructure-template.yaml
        parameters:
            ENVIRONMENT: DV1
            SERVICE_ACCOUNT_NAME: 'sp_dv1_rsg_eu2_ucx'
            AZURE_RESOURCE_GROUP: 'dv1_rsg_eu2_ucx'
            TERRAFORM_BACKEND_STORAGE_ACCOUNT: 'eu2dv1ucxstateocrretry'
            TERRAFORM_BACKEND_CONTAINER_NAME: 'terraform-state-container'
            BACKEND_AZURE_RM_KEY: 'ocrretry.tfstate'

  - stage: DV1Deploy
    displayName: "Deploy for DV1 Ocr Retry Function"
    dependsOn:
      - DV1Infrastructure
      - Build
    jobs:
      - template: ./ocr-retry-function-pipeline-Deploy-template.yaml
        parameters:
              ENVIRONMENT: DV1
              SERVICE_ACCOUNT_NAME: 'sp_dv1_rsg_eu2_ucx'
              AZURE_RESOURCE_GROUP: 'dv1_rsg_eu2_ucx'
              APP_NAME: 'eheu2dv1-af-ucxaclocrretry'

  - stage: IN1Infrastructure
    displayName: "Create infrastructure for INTG Ocr Retry Function"
    dependsOn:
      - Build
    jobs:
      - template: ./ocr-retry-function-pipeline-Infrastructure-template.yaml
        parameters:
            ENVIRONMENT: IN1
            SERVICE_ACCOUNT_NAME: 'sp_in1_rsg_eu2_ucx'
            AZURE_RESOURCE_GROUP: 'in1_rsg_eu2_ucx'
            TERRAFORM_BACKEND_STORAGE_ACCOUNT: 'eu2in1ucxstateocrretry'
            TERRAFORM_BACKEND_CONTAINER_NAME: 'terraform-state-container'
            BACKEND_AZURE_RM_KEY: 'ocrretry.tfstate'

  - stage: IN1Deploy
    displayName: "Deploy for IN1 Ocr Retry Function"
    dependsOn:
      - IN1Infrastructure
    jobs:
      - template: ./ocr-retry-function-pipeline-Deploy-template.yaml
        parameters:
              ENVIRONMENT: IN1
              SERVICE_ACCOUNT_NAME: 'sp_in1_rsg_eu2_ucx'
              AZURE_RESOURCE_GROUP: 'in1_rsg_eu2_ucx'
              APP_NAME: 'eheu2in1-af-ucxaclocrretry'

  - stage: PD1Infrastructure
    displayName: "Create infrastructure for PD1 Ocr Retry Function"
    dependsOn: [ ]
    jobs:
      - template: ./ocr-retry-function-pipeline-Infrastructure-template.yaml
        parameters:
              ENVIRONMENT: PD1
              SERVICE_ACCOUNT_NAME: 'sp_pd1_rsg_cus_ucx'
              AZURE_RESOURCE_GROUP: 'pd1_rsg_cus_ucx'
              TERRAFORM_BACKEND_STORAGE_ACCOUNT: 'cuspd1ucxstateocrretry'
              TERRAFORM_BACKEND_CONTAINER_NAME: 'terraform-state-container'
              BACKEND_AZURE_RM_KEY: 'ocrretry.tfstate'

  - stage: PD1Deploy
    displayName: "Deploy for PD1 Ocr Retry Function"
    dependsOn:
      - PD1Infrastructure
      - Build
    jobs:
      - template: ./ocr-retry-function-pipeline-Deploy-template.yaml
        parameters:
              ENVIRONMENT: PD1
              SERVICE_ACCOUNT_NAME: 'sp_pd1_rsg_cus_ucx'
              AZURE_RESOURCE_GROUP: 'pd1_rsg_cus_ucx'
              APP_NAME: 'ehcuspd1-af-ucxaclocrretry'


Deply.yaml
parameters:
  - name: ENVIRONMENT
    type: string
    values:
      - DV1
      - IN1
      - PD1
  - name: SERVICE_ACCOUNT_NAME
    type: string
  - name: AZURE_RESOURCE_GROUP
    type: string
  - name: APP_NAME
    type: string

jobs:
  - deployment: Deploy
    environment: ${{ parameters.ENVIRONMENT }}
    timeoutInMinutes: 0
    strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self
                - task: DownloadPipelineArtifact@2
                  displayName: Download Build Artifacts
                  inputs:
                    patterns: '**'
                    path: $(Build.ArtifactStagingDirectory)
                - task: AzureFunctionApp@1
                  displayName: Deploy Azure App Service
                  inputs:
                    azureSubscription: ${{ parameters.SERVICE_ACCOUNT_NAME }}
                    appName: ${{ parameters.APP_NAME }}
                    appType: "functionAppLinux"
                    package: >-
                      $(Build.ArtifactStagingDirectory)/BuildArtifacts/OcrRetryFunction/*.zip
                    deployToSlotOrASE: true
                    resourceGroupName: ${{ parameters.AZURE_RESOURCE_GROUP }}
                - task: UseDotNet@2
                  displayName: Use .NET 8 sdk
                  inputs:
                    packageType: sdk
                    version: '8.0.x'
                    installationPath: $(Agent.ToolsDirectory)/dotnet

functionpipeline.yaml
trigger:
  branches:
    include:
      - master

name: 1.0.$(Year:yy)$(DayOfYear).$(rev:r)

pool:
  name: $(buildAgent)

variables:
  buildConfiguration: Release
  isMaster: '$[eq(variables[''Build.SourceBranch''], ''refs/heads/master'')]'
  VSTS_ARM_REST_IGNORE_SSL_ERRORS: true
  system.debug: false
stages:
  - stage: Build
    jobs:
      - job: Test
        steps:
        - task: UseDotNet@2
          displayName: 'Install .NET Core SDK'
          inputs:
            version: 8.x
            performMultiLevelLookup: true
            includePreviewVersions: false
        - task: DotNetCoreCLI@2
          displayName: dotnet restore
          inputs:
            command: 'restore'
            feedsToUse: 'config'
            nugetConfigPath: 'NuGet.Config'
        - task: DotNetCoreCLI@2
          displayName: dotnet build
          inputs:
            command: 'build'
            feedsToUse: 'config'
            nugetConfigPath: 'NuGet.Config'
        - task: DotNetCoreCLI@2
          displayName: dotnet test
          inputs:
            command: 'test'
            feedsToUse: 'config'
            nugetConfigPath: 'NuGet.Config'
      - job: BuildACLFunction
        workspace:
          clean: all
        steps:
          - task: UseDotNet@2
            displayName: 'Install .NET 8 SDK'
            inputs:
              packageType: 'sdk'
              version: '8.0.x'
              performMultiLevelLookup: true
          - task: DotNetCoreCLI@2
            displayName: nuget Restore
            inputs:
              command: 'restore'
              feedsToUse: 'config'
              nugetConfigPath: 'NuGet.Config'
              projects: '**/*.csproj'

          - task: DotNetCoreCLI@2
            displayName: Compile Domain
            inputs:
              command: build
              projects: '**/*Domain.csproj'
          - task: DotNetCoreCLI@2
            displayName: Compile Repo
            inputs:
              command: build
              projects: '**/*Repo.csproj'
          - task: DotNetCoreCLI@2
            displayName: Compile services
            inputs:
              command: build
              projects: '**/*Services.csproj'
          - task: DotNetCoreCLI@2
            displayName: Compile function
            inputs:
              command: build
              projects: '**/*Function.csproj'
          - task: DotNetCoreCLI@2
            displayName: Publish .net 8
            inputs:
              command: publish
              publishWebProjects: false
              projects: '**/UCX.ACLService.Function/*.csproj'
              arguments: >-
                --configuration $(buildConfiguration) --output
                $(Build.ArtifactStagingDirectory)/functions
              zipAfterPublish: true
          - task: PublishBuildArtifacts@1
            displayName: Publish Package
            inputs:
              PathtoPublish: $(Build.ArtifactStagingDirectory)
              ArtifactName: BuildArtifacts

  - stage: DV1Resources
    displayName: DV1-Create Azure Resources
    condition: or(contains(variables['Build.SourceBranch'], 'refs/tags'), eq(variables['Build.Reason'], 'Manual'), eq(variables.isMaster, true))
    dependsOn: []
    variables:
      SERVICE_ACCOUNT_NAME: 'sp_dv1_rsg_ucx'
      AZURE_RESOURCE_GROUP: 'dv1_rsg_ucx-linux'
      TERRAFORM_BACKEND_STORAGE_ACCOUNT: 'eu2dv1staucxtfstate'
      TERRAFORM_BACKEND_CONTAINER_NAME: 'terraform-aclservice-container'
      BACKEND_AZURE_RM_KEY: 'ucx-acl-function.tfstate'
    jobs:
      - deployment: DevResources
        environment: DV1
        timeoutInMinutes: 0
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self
                - task: >-
                    ms-devlabs.custom-terraform-tasks.custom-terraform-installer-task.TerraformInstaller@0
                  displayName: Install Terraform
                  inputs:
                    terraformVersion: 1.0.11
                - powershell: |
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%2520Modules'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%20Platform'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%2520Platform'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/UCX/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/UCX'
                    git config --global -l
                  displayName: Git url rewrite

                - task: TerraformTaskV2@2
                  displayName: 'Terraform : init'
                  inputs:
                    workingDirectory: "Infrastructure.Function/ImageOneFunction"
                    backendServiceArm: ${{ variables.SERVICE_ACCOUNT_NAME }}
                    backendAzureRmResourceGroupName: $(AZURE_RESOURCE_GROUP)
                    backendAzureRmStorageAccountName: $(TERRAFORM_BACKEND_STORAGE_ACCOUNT)
                    backendAzureRmContainerName: $(TERRAFORM_BACKEND_CONTAINER_NAME)
                    backendAzureRmKey: $(BACKEND_AZURE_RM_KEY)
                - task: TerraformTaskV2@2
                  displayName: 'Terraform : plan'
                  inputs:
                    command: plan
                    workingDirectory: "./Infrastructure.Function/ImageOneFunction"
                    environmentServiceNameAzureRM: sp_dv1_rsg_ucx-linux
                    commandOptions: '--var-file=Environments/dv1.tfvars -out=tfplan'
                - task: TerraformTaskV2@2
                  displayName: 'Terraform : apply'
                  inputs:
                    command: apply
                    workingDirectory: Infrastructure.Function/ImageOneFunction
                    environmentServiceNameAzureRM: sp_dv1_rsg_ucx-linux
                    commandOptions: '-auto-approve tfplan'
                - task: DownloadPipelineArtifact@2
                  displayName: Download Build Artifacts
                  inputs:
                    patterns: '**'
                    path: $(Build.ArtifactStagingDirectory)

  - stage: DV1Deploy
    displayName: DV1-Deploy code to ASE
    condition: or(contains(variables['Build.SourceBranch'], 'refs/tags'), eq(variables['Build.Reason'], 'Manual'), eq(variables.isMaster, true))
    dependsOn:
    - DV1Resources
    - Build
    jobs:
      - deployment: DevDeploy
        environment: DV1
        timeoutInMinutes: 0
        variables:
          ConnectionString: $(ConnectionString)
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self
                - task: DownloadPipelineArtifact@2
                  displayName: Download Build Artifacts
                  inputs:
                    patterns: '**'
                    path: $(Build.ArtifactStagingDirectory)
                - task: AzureFunctionApp@1
                  displayName: Deploy Azure App private endpoint Service
                  inputs:
                    azureSubscription: sp_dv1_rsg_ucx-linux
                    appName: eheu2dv1-af-ucxaclservice-ef-pvt
                    package: >-
                      $(Build.ArtifactStagingDirectory)/BuildArtifacts/functions/*.zip
                    deployToSlotOrASE: true
                    resourceGroupName: dv1_rsg_ucx-linux
                    slotName: staging
                - task: AzureAppServiceManage@0
                  displayName: Swap api-pvt deployment slots
                  inputs:
                    azureSubscription: sp_dv1_rsg_ucx-linux
                    WebAppName: eheu2dv1-af-ucxaclservice-ef-pvt
                    resourceGroupName: dv1_rsg_ucx-linux
                    SourceSlot: staging
                    SwapWithProduction: true
                - task: UseDotNet@2
                  displayName: Use .NET 8 sdk
                  inputs:
                    packageType: sdk
                    version: '8.0.x'
                    installationPath: $(Agent.ToolsDirectory)/dotnet
  - stage: IN1Resources
    displayName: INTG-Create Azure Resources
    dependsOn:
    - Build
    jobs:
      - deployment: IntResources
        environment: IN1
        timeoutInMinutes: 0
        variables:
          SERVICE_ACCOUNT_NAME: 'sp_in1_rsg_ucx'
          AZURE_RESOURCE_GROUP: 'in1_rsg_ucx-linux'
          TERRAFORM_BACKEND_STORAGE_ACCOUNT: 'eu2in1staucxtfstate'
          TERRAFORM_BACKEND_CONTAINER_NAME: 'terraform-aclservice-container'
          BACKEND_AZURE_RM_KEY: 'ucx-acl-function.tfstate'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self

                - task: ms-devlabs.custom-terraform-tasks.custom-terraform-installer-task.TerraformInstaller@0
                  displayName: "Install Terraform"
                  inputs:
                    terraformVersion: 1.0.11
                - powershell: |
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%2520Modules'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%20Platform'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%2520Platform'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/UCX/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/UCX'
                    git config --global -l
                  displayName: Git url rewrite

                - task: TerraformTaskV2@2
                  displayName: 'Terraform : init'
                  inputs:
                    workingDirectory: "Infrastructure.Function/ImageOneFunction"
                    backendServiceArm: ${{ variables.SERVICE_ACCOUNT_NAME }}
                    backendAzureRmResourceGroupName: $(AZURE_RESOURCE_GROUP)
                    backendAzureRmStorageAccountName: $(TERRAFORM_BACKEND_STORAGE_ACCOUNT)
                    backendAzureRmContainerName: $(TERRAFORM_BACKEND_CONTAINER_NAME)
                    backendAzureRmKey: $(BACKEND_AZURE_RM_KEY)
                - task: TerraformTaskV2@2
                  displayName: 'Terraform : plan'
                  inputs:
                    command: plan
                    workingDirectory: "./Infrastructure.Function/ImageOneFunction"
                    environmentServiceNameAzureRM: sp_in1_rsg_ucx-linux
                    commandOptions: '--var-file=Environments/in1.tfvars -out=tfplan'
                - task: TerraformTaskV2@2
                  displayName: 'Terraform : apply'
                  inputs:
                    command: apply
                    workingDirectory: "./Infrastructure.Function/ImageOneFunction"
                    environmentServiceNameAzureRM: sp_in1_rsg_ucx-linux
                    commandOptions: '-auto-approve tfplan'
                - task: DownloadPipelineArtifact@2
                  displayName: Download Build Artifacts
                  inputs:
                    patterns: '**'
                    path: $(Build.ArtifactStagingDirectory)

  - stage: IN1Deploy
    displayName: IN1-Deploy code to ASE
    condition: or(contains(variables['Build.SourceBranch'], 'refs/tags'), eq(variables['Build.Reason'], 'Manual'), eq(variables.isMaster, true))
    dependsOn:
    - IN1Resources
    jobs:
      - deployment: IN1Deploy
        environment: IN1
        timeoutInMinutes: 0
        variables:
          ConnectionString: $(ConnectionString)
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self
                - task: DownloadPipelineArtifact@2
                  displayName: Download Build Artifacts
                  inputs:
                    patterns: '**'
                    path: $(Build.ArtifactStagingDirectory)
                - task: AzureFunctionApp@1
                  displayName: Deploy Azure App private endpoint Service
                  inputs:
                    azureSubscription: sp_in1_rsg_ucx-linux
                    appName: eheu2in1-af-ucxaclservice-ef-pvt
                    package: >-
                      $(Build.ArtifactStagingDirectory)/BuildArtifacts/functions/*.zip
                    deployToSlotOrASE: true
                    resourceGroupName: in1_rsg_ucx-linux
                    slotName: staging
                - task: AzureAppServiceManage@0
                  displayName: Swap api-pvt deployment slots
                  inputs:
                    azureSubscription: sp_in1_rsg_ucx-linux
                    WebAppName: eheu2in1-af-ucxaclservice-ef-pvt
                    resourceGroupName: in1_rsg_ucx-linux
                    SourceSlot: staging
                    SwapWithProduction: true
                - task: UseDotNet@2
                  displayName: Use .NET 8 sdk
                  inputs:
                    packageType: sdk
                    version: '8.0.x'
                    installationPath: $(Agent.ToolsDirectory)/dotnet
  - stage: PD1Resources
    condition: or(contains(variables['Build.SourceBranch'], 'refs/tags'), eq(variables['Build.Reason'], 'Manual'), eq(variables.isMaster, true))
    displayName: Prod-Create Azure Resources and apply DB
    dependsOn:
    - Build
    variables:
      SERVICE_ACCOUNT_NAME: 'sp_pd1_rsg_eu2_ucx'
      AZURE_RESOURCE_GROUP: 'pd1_rsg_eu2_ucx-linux'
      TERRAFORM_BACKEND_STORAGE_ACCOUNT: 'eu2pd1staucxtfstate'
      TERRAFORM_BACKEND_CONTAINER_NAME: 'terraform-aclservice-container'
      BACKEND_AZURE_RM_KEY: 'ucx-acl-function.tfstate'
    jobs:
      - deployment: PD1Resources
        environment: PD1
        timeoutInMinutes: 0
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self

                - task: ms-devlabs.custom-terraform-tasks.custom-terraform-installer-task.TerraformInstaller@0
                  displayName: "Install Terraform"
                  inputs:
                    terraformVersion: 1.0.11
                - powershell: |
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%2520Modules'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%20Platform'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%2520Platform'
                    git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/UCX/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/UCX'
                    git config --global -l
                  displayName: Git url rewrite

                - task: TerraformTaskV2@2
                  displayName: 'Terraform : init'
                  inputs:
                    workingDirectory: "Infrastructure.Function/ImageOneFunction"
                    backendServiceArm: ${{ variables.SERVICE_ACCOUNT_NAME }}
                    backendAzureRmResourceGroupName: $(AZURE_RESOURCE_GROUP)
                    backendAzureRmStorageAccountName: $(TERRAFORM_BACKEND_STORAGE_ACCOUNT)
                    backendAzureRmContainerName: $(TERRAFORM_BACKEND_CONTAINER_NAME)
                    backendAzureRmKey: $(BACKEND_AZURE_RM_KEY)

                - task: TerraformTaskV2@2
                  displayName: 'Terraform : plan'
                  inputs:
                    command: plan
                    workingDirectory: "./Infrastructure.Function/ImageOneFunction"
                    environmentServiceNameAzureRM: sp_pd1_rsg_eu2_ucx-linux
                    commandOptions: '--var-file=Environments/pd1.tfvars -out=tfplan'
                - task: TerraformTaskV2@2
                  displayName: 'Terraform : apply'
                  inputs:
                    command: apply
                    workingDirectory: "./Infrastructure.Function/ImageOneFunction"
                    environmentServiceNameAzureRM: sp_pd1_rsg_eu2_ucx-linux
                    commandOptions: '-auto-approve tfplan'
                - task: DownloadPipelineArtifact@2
                  displayName: Download Build Artifacts
                  inputs:
                    patterns: '**'
                    path: $(Build.ArtifactStagingDirectory)

  - stage: PD1Deploy
    condition: or(contains(variables['Build.SourceBranch'], 'refs/tags'), eq(variables['Build.Reason'], 'Manual'), eq(variables.isMaster, true))
    displayName: Prod-Deploy code to ASE
    dependsOn:
    - PD1Resources
    jobs:
      - deployment: PD1Deploy
        environment: PD1
        timeoutInMinutes: 0
        pool:
          name: AzureProd
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self
                - task: DownloadPipelineArtifact@2
                  displayName: Download Build Artifacts
                  inputs:
                    patterns: '**'
                    path: $(Build.ArtifactStagingDirectory)
                - task: AzureFunctionApp@1
                  displayName: Deploy Azure App private endpoint Service
                  inputs:
                    azureSubscription: sp_pd1_rsg_eu2_ucx-linux
                    appName: eheu2pd1-af-ucxaclservice-ef-pvt
                    package: >-
                      $(Build.ArtifactStagingDirectory)/BuildArtifacts/functions/*.zip
                    deployToSlotOrASE: true
                    resourceGroupName: pd1_rsg_eu2_ucx-linux
                    slotName: staging
                - task: AzureAppServiceManage@0
                  displayName: Swap api-pvt deployment slots
                  inputs:
                    azureSubscription: sp_pd1_rsg_eu2_ucx-linux
                    WebAppName: eheu2pd1-af-ucxaclservice-ef-pvt
                    resourceGroupName: pd1_rsg_eu2_ucx-linux
                    SourceSlot: staging
                    SwapWithProduction: true



Thanks and Regards
Siraj

From: R, Sirajudeen (CTR) 
Sent: Thursday, August 22, 2024 3:57 PM
To: R, Sirajudeen (CTR) <sirajudeen.r@evicore.com>
Subject: RE: azfnctrig

using Microsoft.ApplicationInsights.Extensibility;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.CookiePolicy;
using Microsoft.AspNetCore.Http;
using Microsoft.Azure.Functions.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Serilog;
using Serilog.Events;
using Serilog.Exceptions;
using Serilog.Extensions.Logging;
using System;
using UCX.ACLService.Domain.Models;
using UCX.ACLService.Function.OcrRetry.Configuration;
using UCX.ACLService.Repo.Service;
using UCX.ACLService.Services.OVHelper;
namespace UCX.ACLService.Function.OcrRetry
{
    public class Startup
    {
        public void Configure(IServiceCollection services)
        {
            var config = new ConfigurationBuilder()
                .SetBasePath(Environment.CurrentDirectory)
                .AddJsonFile("local.settings.json", true, true)
                .AddEnvironmentVariables()
                .Build();

            services.Configure<CookiePolicyOptions>(option =>
            {
                option.Secure = CookieSecurePolicy.Always;
                option.HttpOnly = HttpOnlyPolicy.Always;
            });

            var loggerConfiguration = new LoggerConfiguration().ReadFrom.Configuration(config);
            var telemetryConfiguration = TelemetryConfiguration.CreateDefault();
            telemetryConfiguration.InstrumentationKey = config.GetValue<string>("ApplicationInsights:InstrumentationKey");

            Log.Logger = loggerConfiguration
                .ReadFrom.Configuration(config)
                .Enrich.FromLogContext()
                .Enrich.WithExceptionDetails()
                .Enrich.WithAssemblyName()
                .Enrich.WithAssemblyVersion()
                .WriteTo.Async(l =>
                {
                l.ApplicationInsights(telemetryConfiguration,
                    new SerilogAppInsightsTraceTelemetryConverter(),
                    LogEventLevel.Debug
                    );
                })
                .Enrich.WithDynamicProperty("Platform", () => "UCX")
                .Enrich.WithDynamicProperty("Application", () => "UCX.OcrRetry.FunctionApp")
                //.WriteTo.Debug()
                .WriteTo.Console(outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}")
                .CreateLogger();

            services.AddLogging(lb =>
            {
                lb.AddSerilog(Log.Logger, true);
            });

            services.Configure<AppSettingsModel>(config);

            services.AddHealthChecks();

            ObjectValetConfiguration.Bind(config, services);
            CosmosConfiguration.RegisterDependency(config, services, false);
            DocumentAttachedRepository.RegisterDependency(services);
            ObjectValetClient.RegisterDependency(services, config.GetValue<int>("ObjectValet:Attempts"));
        }
    }
}


using Microsoft.Extensions.Hosting;
using UCX.ACLService.Function.OcrRetry;

var host = new HostBuilder()
    .ConfigureFunctionsWorkerDefaults()
    .ConfigureAppConfiguration((hostingContext, configBuilder) =>
    {
        var env = hostingContext.HostingEnvironment;
    })
    .ConfigureServices((appBuilder, services) =>
    {
        new Startup().Configure(services);
    })
    .Build();

host.Run();


{
  "version": "2.0",
  "logging": {
    "logLevel": {
      "default": "Debug"
    },
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    }
  }
}


using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;

namespace UCX.ACLService.Function.OcrRetry;

public static class HealthCheckFunction
{
    [Function(nameof(HealthCheckFunction))]
    public static IActionResult Health([HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "health")] HttpRequest request, ILogger logger)
    {
        return new OkObjectResult("healthy");
    }
}


using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
using UCX.ACLService.Repo.Interface;
using UCX.ACLService.Services.OVHelper;

namespace UCX.ACLService.Function.OcrRetry;

public class FunctionTimerOcr
{
    private readonly ILogger<FunctionTimerOcr> _logger;
    private readonly IObjectValetClient _objectValetClient;
    private readonly IDocumentAttachedRepository _repo;
    private readonly Dictionary<string, object> _scope = new();

    public FunctionTimerOcr(
        ILogger<FunctionTimerOcr> logger,
        IObjectValetClient objectValetClient,
        IDocumentAttachedRepository repo
    )
    {
        _scope.Add("Class", nameof(FunctionTimerOcr));
        _logger = logger;
        _objectValetClient = objectValetClient;
        _repo = repo;
    }

    [Function(nameof(FunctionTimerOcrRetry))]
    public async Task FunctionTimerOcrRetry([TimerTrigger("0 */15 * * * * ")] TimerInfo myTimer, ILogger log)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "FunctionTimerOcrRetry" }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation(
                "Timer trigger function {FunctionName}", nameof(FunctionTimerOcrRetry));
            var original = DateTime.UtcNow;
            var updated = original.Add(new TimeSpan(0, -15, 0));
            _logger.LogDebug("Get attachments");
            var attachments = (await _repo.GetItemsNotTransferedAsync(updated)).ToList();
            _logger.LogInformation("check attachments numbers:{Count}", attachments.Count);
            if (!attachments.Any())
                return;

            foreach (var attachment in attachments)
            {
                _logger.LogInformation("Start retry for attachment Object Valet ID: {Ovid}", attachment.id);
                _logger.LogDebug("check attachment retry: {RetryCount}", attachment.RetryCount);
                if (attachment.RetryCount > 4)
                {
                    _logger.LogInformation("Do not get OCRCompleteEvent for attachment Object Valet ID: {Ovid}",
                        attachment.id);
                    continue;
                }

                attachment.PostedDateTime = DateTime.UtcNow;
                attachment.RetryCount++;
                await _repo.UpdateAsync(attachment);
                if (attachment.SystemOfRecordContextKey == null || attachment.FileName == null ||
                    attachment.UserName == null)
                {
                    _logger.LogInformation("attachment info is null for attachment Object Valet ID: {Ovid}",
                        attachment.id);
                    continue;
                    ;
                }

                await _objectValetClient.PostObject(attachment.SystemOfRecordContextKey, attachment.FileName,
                    long.Parse(attachment.id), attachment.UserName);
                _logger.LogInformation("Finish retry for attachment Object Valet ID: {Ovid}", attachment.id);
            }
        }
    }
}


using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;

using Microsoft.Azure.WebJobs.Extensions.OpenApi.Core.Attributes;
using Microsoft.Azure.WebJobs.Extensions.OpenApi.Core.Enums;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi.Models;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using ucx.messages.events;
using ucx.messages.models;
using UCX.ACLService.Domain.Models;
using UCX.ACLService.Services.Services.Interface;

namespace UCX.ACLService.Function
{
    public class FunctionHTTP
    {
        private readonly ILogger<FunctionHTTP> _logger;
        private readonly IImageOneService _imageOneMDMService;
        private readonly IUCXProducer<UCXUserConfigurationImported> _ucxUserConfigurationImportedSenderService;

        public FunctionHTTP(ILogger<FunctionHTTP> log, IImageOneService imageOneMDMService, IUCXProducer<UCXUserConfigurationImported> ucxUserConfigurationImportedSenderService)
        {
            _logger = log;
            _imageOneMDMService = imageOneMDMService;
            _ucxUserConfigurationImportedSenderService = ucxUserConfigurationImportedSenderService;
        }

        [Function(nameof(GetImageOneTestConnection))]
        [OpenApiOperation(operationId: "Run", tags: new[] { "name" })]
        [OpenApiSecurity("function_key", SecuritySchemeType.ApiKey, Name = "code", In = OpenApiSecurityLocationType.Query)]
        [OpenApiResponseWithBody(statusCode: HttpStatusCode.OK, contentType: "text/plain", bodyType: typeof(string), Description = "The OK response")]
        public async Task<IActionResult> GetImageOneTestConnection([HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest? req =null)
        {
            _logger.LogInformation($"C# HTTP trigger function processed {nameof(GetImageOneTestConnection)} request.");

            var response = await _imageOneMDMService.GetImageOneTestConnection();

            var simpleResponseBooleanModel = new SimpleResponseBooleanModel { Response = response };

            return new OkObjectResult(simpleResponseBooleanModel);
        }

        [Function(nameof(GetImageOneLicense))]
        [OpenApiOperation(operationId: "Run", tags: new[] { "name" })]
        [OpenApiSecurity("function_key", SecuritySchemeType.ApiKey, Name = "code", In = OpenApiSecurityLocationType.Query)]
        [OpenApiResponseWithBody(statusCode: HttpStatusCode.OK, contentType: "text/plain", bodyType: typeof(string), Description = "The OK response")]
        public async Task<IActionResult> GetImageOneLicense([HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest? req=null)
        {
            _logger.LogInformation($"C# HTTP trigger function processed a {nameof(GetImageOneLicense)} request.");

            var response = await _imageOneMDMService.GetImageOneLicense();

            var distinctUsers = response.Select(d => d.UserId).Distinct();
            foreach (var user in distinctUsers)
            {
                var userLicenses = response.Where(d => d.UserId == user);

                var userEvent = new UCXUserConfigurationImported
                {
                    UserId = user,
                    StateLicenses = userLicenses.Select(l => new StateLicense
                    {
                        BoardCertType = l.BoardCertType,
                        StateCode = l.LicenseState
                    }).ToList()
                };

                await _ucxUserConfigurationImportedSenderService.SendAsync(userEvent);
            }

            var simpleResponseBooleanModel = new SimpleResponseBooleanModel { Response = true };

            return new OkObjectResult(simpleResponseBooleanModel);
        }
    }
}


terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = ">=3.50.0"
    }
  }

  backend "azurerm" {}
}

provider "azurerm" {
  features {}
}

provider "azurerm" {
  features {}
  alias           = "apim_provider"
  subscription_id = var.apim_subscription
}

data "azurerm_resource_group" "current_rsg" {
  name = var.resource_group_name
}

data "azurerm_subscription" "current" {}

locals {
  location_abbreviations = {
    eastus         = "eu1"
    eastus2        = "eu2"
    westus         = "wu1"
    westus2        = "wu2"
    centralus      = "cus"
    southcentralus = "scu"
  }
}


data "azurerm_client_config" "current" {
}

module "azure_key_vault" {
  source                      = "git::ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules/ep-key-vault?ref=v2.0.0"
  environment                 = var.environment
  location                    = data.azurerm_resource_group.current_rsg.location
  product                     = var.product
  domain                      = "acl"
  resource_group_name         = var.resource_group_name
  tenant_id                   = data.azurerm_client_config.current.tenant_id
  monitor_action_group_ids    = [azurerm_monitor_action_group.monitor_action_group.id]
  enabled_for_disk_encryption = false
  purge_protection_enabled    = true
  bypass_network_rules        = true
  cost_center                 = local.tags.CostCenter
  asset_owner                 = local.tags.AssetOwner
  business_owner              = local.tags.BusinessOwner
  data_classification         = local.tags.DataClassification
  app_name                    = local.tags.AppName
  it_sponsor                  = local.tags.ITSponsor
  tier                        = local.tags.Tier
  app_team                    = local.tags.AppTeam
  app_owner                   = local.tags.AppOwner
  service_now_ba              = local.tags.ServiceNowBA
  service_now_as              = local.tags.ServiceNowAS
  security_review_id          = local.tags.SecurityReviewID
  vnet_subnets                = local.integration_vnets
}

module "default_access_policy" {
  source             = "git::ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%20Platform/ep-terraform-modules//azure-key-vault-access-policy/resource?ref=v1.5.3"
  key_vault_id       = module.azure_key_vault.id
  tenant_id          = data.azurerm_client_config.current.tenant_id
  object_id          = data.azurerm_client_config.current.object_id
  key_permissions    = ["Get", "List", "Update", "Create", "Delete", "Recover", "Backup", "Restore"]
  secret_permissions = ["Backup", "Delete", "Get", "List", "Purge", "Recover", "Restore", "Set"]
}

module "users_keyvault_access_policy" {
  source             = "git::ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules/ep-key-vault-access-policy?ref=v1.0.0"
  key_vault_id       = module.azure_key_vault.id
  tenant_id          = data.azurerm_client_config.current.tenant_id
  for_each           = local.all_users
  object_id          = each.value
  key_permissions    = ["Get", "List", "Update", "Create", "Delete", "Recover", "Backup", "Restore"]
  secret_permissions = ["Backup", "Delete", "Get", "List", "Purge", "Recover", "Restore", "Set"]
}
module "private_endpoint_keyvault" {
  source                    = "git@ssh.dev.azure.com:v3/eviCoreDev/Terraform%20Modules/ep-private-endpoint?ref=v1.1.1"
  environment               = var.environment
  location                  = var.location
  domain                    = "acl-pvt"
  product                   = "ucx"
  resource_group_name       = data.azurerm_resource_group.current_rsg.name
  resource_id               = module.azure_key_vault.id
  subnet_id_integration     = var.subnet_id_integration
  subnet_id_private         = var.subnet_id_private
  swift_connection_required = false
  subresources              = ["vault"]
  timeout_create            = "6h"

  bc_tier                   = local.tags.Tier
  cost_center               = local.tags.CostCenter
  it_sponsor                = local.tags.ITSponsor
  asset_owner               = local.tags.AssetOwner
  app_name                  = local.tags.AppName
  business_owner            = local.tags.BusinessOwner
  data_classification       = local.tags.DataClassification
  app_team                  = local.tags.AppTeam
  app_owner                 = local.tags.AppOwner
  service_now_ba            = local.tags.ServiceNowBA
  service_now_as            = local.tags.ServiceNowAS
  security_review_id        = local.tags.SecurityReviewID
}

module "api_pvt_access_policy_v1" {
  source             = "git::ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules/ep-key-vault-access-policy?ref=v1.0.0"
  key_vault_id       = module.azure_key_vault.id
  tenant_id          = data.azurerm_client_config.current.tenant_id
  object_id          = module.afacl_api.app.identity[0].principal_id
  key_permissions         = ["Create", "Decrypt", "Encrypt", "Get", "Import", "List", "Recover", "Restore", "Update"]
  secret_permissions      = ["Backup", "List", "Get", "Recover", "Restore", "Set"]
  certificate_permissions = ["Get", "List", "Update", "Create", "Recover", "Backup", "Restore", "ManageContacts", "ManageIssuers", "GetIssuers", "SetIssuers"]
}

module "api_slot_pvt_access_policy_v1" {
  source             = "git::ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules/ep-key-vault-access-policy?ref=v1.0.0"
  key_vault_id       = module.azure_key_vault.id
  tenant_id          = data.azurerm_client_config.current.tenant_id
  object_id          = module.afacl_api.slot_principal_id
  key_permissions         = ["Create", "Decrypt", "Encrypt", "Get", "Import", "List", "Recover", "Restore", "Update"]
  secret_permissions      = ["Backup", "List", "Get", "Recover", "Restore", "Set"]
  certificate_permissions = ["Get", "List", "Update", "Create", "Recover", "Backup", "Restore", "ManageContacts", "ManageIssuers", "GetIssuers", "SetIssuers"]
}


resource "azurerm_storage_account" "module" {
  name                             = "eh${var.region}${var.environment}saccaclinfra"
  resource_group_name              = data.azurerm_resource_group.current_rsg.name
  location                         = var.location
  account_tier                     = "Standard"
  account_replication_type         = "LRS"
  tags                             = merge(local.tags,local.dataRestTags)
  min_tls_version                  = "TLS1_2"
  cross_tenant_replication_enabled = false
  allow_nested_items_to_be_public  = false
}

resource "azurerm_storage_container" "faults-prescription" {
  name                  = "kafkasecurity"
  container_access_type = "private"
  storage_account_name  = azurerm_storage_account.module.name
}
module "service_plan" {
  source              = "git::ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules/ep-app-service-plan?ref=v2.0.2"
  environment         = var.environment
  location            = var.location
  domain              = "${var.domain}-ef-pvt"
  product             = var.product
  resource_group_name = data.azurerm_resource_group.current_rsg.name
  sku_name            = var.sku_name
  os_type             = "Windows"
  per_site_scaling    = false
  worker_count        = var.worker_count
  timeout_create      = "6h"
  bc_tier             = local.tags.Tier
  cost_center         = local.tags.CostCenter
  it_sponsor          = local.tags.ITSponsor
  asset_owner         = local.tags.AssetOwner
  app_name            = local.tags.AppName
  business_owner      = local.tags.BusinessOwner
  data_classification = local.tags.DataClassification
  service_now_ba      = local.tags.ServiceNowBA
  service_now_as      = local.tags.ServiceNowAS
  security_review_id  = local.tags.SecurityReviewID
}
module "afacl_api" {
  source                             = "git::ssh://git@ssh.dev.azure.com/v3/eviCoreDev/UCX/modules-function-app//windows/function-app-with-slot?ref=v1.1.0"
  environment                        = var.environment
  domain                             = "${var.domain}-ef-pvt"
  location                           = var.location
  resource_group_name                = var.resource_group_name
  service_plan_id                    = module.service_plan.id
  appsettings                        = local.app_settings_pvt
  cost_center                        = local.tags.CostCenter
  asset_owner                        = local.tags.AssetOwner
  business_owner                     = local.tags.BusinessOwner
  data_classification                = local.tags.DataClassification
  app_name                           = local.tags.AppName
  it_sponsor                         = local.tags.ITSponsor
  tier                               = local.tags.Tier
  service_now_ba                     = local.tags.ServiceNowBA
  service_now_as                     = local.tags.ServiceNowAS
  security_review_id                 = local.tags.SecurityReviewID
  health_check_path                  = "/api/health"
  dotnet_version                     = local.application_stack.dotnet_version
  use_dotnet_isolated_runtime        = local.application_stack.use_dotnet_isolated_runtime
  subnet_id_integration              = var.subnet_id_integration
  subnet_id_private                  = var.subnet_id_private
  app_team                           = "Gravity"
  monitor_action_group_id            = azurerm_monitor_action_group.monitor_action_group.id
  storage_domain                     = "${var.domain}"
}


locals {
  app_settings = {
    "WEBSITE_ENABLE_SYNC_UPDATE_SITE"   = "true"
    "WEBSITE_RUN_FROM_PACKAGE"          = "1"
    "FUNCTIONS_WORKER_RUNTIME"          = "dotnet-isolated"
    "AzureWebJobsStorage"               = azurerm_storage_account.module.primary_connection_string
    "AzureWebJobsDashboard"             = azurerm_storage_account.module.primary_connection_string
    "environment"                       = var.environment
    "KafkaBootstrapServers"             = var.Kafka_Cloud_Config.KafkaBootstrapServers
    "SaslUsername"                      = var.Kafka_Cloud_Config.SaslUsername
    "SaslPassword"                      = var.Kafka_Cloud_Config.SaslPassword
    "CertFilename"                      = var.Kafka_Cloud_Config.SslCaLocation
    "StorageAccountConnectionString"    = var.Kafka_Cloud_Config.StorageAccountConnectionString
    "UserTopic"                         = "UCX.UserConfigurationImported"
    "ConnectionString"                  = var.imageOneConnectionString
    "APPINSIGHTS_INSTRUMENTATIONKEY"    = var.app_insights.instrumentation_key
    "Logging__LogLevel__Default"        = var.log_level_function
    "Serilog__MinimumLevel__Default"    = var.log_level_function
  }
  app_settings_pvt = {
    "WEBSITE_ENABLE_SYNC_UPDATE_SITE"   = "true"
    "WEBSITE_RUN_FROM_PACKAGE"          = "1"
    "FUNCTIONS_WORKER_RUNTIME"          = "dotnet-isolated"
    "AzureWebJobsStorage"               = "${module.afacl_api.storage.primary_connection_string}"
    "AzureWebJobsDashboard"             = "${module.afacl_api.storage.primary_connection_string}"
    "environment"                       = var.environment
    "KafkaBootstrapServers"             = var.Kafka_Cloud_Config.KafkaBootstrapServers
    "SaslUsername"                      = var.Kafka_Cloud_Config.SaslUsername
    "SaslPassword"                      = var.Kafka_Cloud_Config.SaslPassword
    "CertFilename"                      = var.Kafka_Cloud_Config.SslCaLocation
    "StorageAccountConnectionString"    = var.Kafka_Cloud_Config.StorageAccountConnectionString
    "UserTopic"                         = "UCX.UserConfigurationImported"
    "ConnectionString"                  = var.imageOneConnectionString
    "APPINSIGHTS_INSTRUMENTATIONKEY"    = var.app_insights.instrumentation_key
    "Logging__LogLevel__Default"        = var.log_level_function
    "Serilog__MinimumLevel__Default"    = var.log_level_function
  }
  tags = {
    CostCenter         = "61700200"
    AssetOwner         = "Gravity"
    BusinessOwner      = "Liz Langkau"
    DataClassification = "Restricted"
    AppName            = "UCX ACL Service"
    ITSponsor          = "Rajesh Sharda"
    Tier               = 1
    AppOwner           = "Gravity"
    AppTeam            = "Gravity"
    ServiceNowBA       = "notAssigned"
    ServiceNowAS       = "notAssigned"
    SecurityReviewID   = "notAssigned"
  }

  dataRestTags = var.dataRestTags

  gravity_users = [
    "477f54da-ee31-4a6c-8888-6c43d7cf29d9", #Ben
    "581b3c0b-1620-4c39-b740-284f7484dfe0", #David
    "13a31833-b439-45e3-ac9c-49307c115096"  #Usman
  ]
  thunder_users = [
    "72b48750-6a9e-46e3-88ac-d2e6d5fd4626", #Carly
    "6592da99-89da-4b64-8431-73dd6cbf506d", #Zac
    "73cc5c4e-8352-4650-92cb-e11d58fdc9f7", #Chad
    "6fc349b5-2a7b-4672-8ee0-83c348b36da8"  #Mouad
  ]

  all_users = toset(concat(local.gravity_users, local.thunder_users))

  integration_vnets     = concat(var.ase_vnet, [var.subnet_id_integration])

  application_stack = {
    "dotnet_version"              = "v8.0"
    "use_dotnet_isolated_runtime" = true
  }
}


resource "azurerm_windows_function_app" "module" {
  name                          = "eh${local.location_abbreviations[var.location]}${var.environment}-af-${var.domain}"
  resource_group_name           = var.resource_group_name
  location                      = var.location
  service_plan_id               = var.service_plan_id
  storage_account_name          = azurerm_storage_account.storage_account.name
  storage_account_access_key    = azurerm_storage_account.storage_account.primary_access_key
  https_only                    = true
  app_settings                  = var.appsettings
  public_network_access_enabled = false

  site_config {
    always_on         = true
    ftps_state        = "Disabled"
    health_check_path = var.health_check_path
    application_stack {
      dotnet_version              = var.dotnet_version
      use_dotnet_isolated_runtime = var.use_dotnet_isolated_runtime
    }
  }

  tags = local.merged_tags

  identity {
    type = "SystemAssigned"
  }

  #If we are using swift connection, virtual_network_subnet_id has to be ignored
  # Also Ignoring changes in the live slot to allow for true blue green deployments. 
  # Changes to site_config, app_settings and connection_string could all potentially cause app downtime. 
  # We want changes to these settings to be applied to the staging slot and swapped in once healthy.
  lifecycle {
    ignore_changes = [virtual_network_subnet_id,
      site_config,
      app_settings,
    connection_string]
  }
  depends_on = [azurerm_storage_account.storage_account]
}
resource "azurerm_windows_function_app_slot" "staging_slot" {
  name                          = "staging"
  function_app_id               = azurerm_windows_function_app.module.id
  storage_account_name          = azurerm_storage_account.storage_account.name
  app_settings                  = var.appsettings
  public_network_access_enabled = false
  site_config {
    always_on         = true
    ftps_state        = "Disabled"
    health_check_path = var.health_check_path
    application_stack {
      dotnet_version              = var.dotnet_version
      use_dotnet_isolated_runtime = var.use_dotnet_isolated_runtime
    }
  }
  tags = local.merged_tags
  identity {
    type = "SystemAssigned"
  }
  depends_on = [azurerm_storage_account.storage_account]
}
resource "azurerm_app_service_virtual_network_swift_connection" "vnet_swift_con" {
  app_service_id = azurerm_windows_function_app.module.id
  subnet_id      = var.subnet_id_integration
  depends_on     = [azurerm_windows_function_app.module]
}

resource "azurerm_monitor_metric_alert" "app_service_failures" {
  name                = "${azurerm_windows_function_app.module.name}-failure-alerts"
  resource_group_name = var.resource_group_name
  scopes              = [azurerm_windows_function_app.module.id]
  action {
    action_group_id = var.monitor_action_group_id
  }

  criteria {
    metric_namespace = "Microsoft.Web/sites"
    metric_name      = "Http5xx"
    aggregation      = "Count"
    operator         = "GreaterThan"
    threshold        = var.failure_alert_settings.threshold
  }

  frequency   = var.failure_alert_settings.frequency
  window_size = var.failure_alert_settings.window_size
  severity    = 2

  tags = local.merged_tags
}

resource "azurerm_monitor_metric_alert" "app_service_health" {
  name                = "${azurerm_windows_function_app.module.name}-availability-alerts"
  resource_group_name = var.resource_group_name
  scopes              = [azurerm_windows_function_app.module.id]
  action {
    action_group_id = var.monitor_action_group_id
  }

  criteria {
    metric_namespace = "Microsoft.Web/sites"
    metric_name      = "HealthCheckStatus"
    aggregation      = "Average"
    operator         = "LessThan"
    threshold        = 100
  }

  severity = 0

  tags = local.merged_tags
}


resource "azurerm_app_service_virtual_network_swift_connection" "azure_function_vnet_con" {
  count          = var.swift_connection_required ? 1 : 0
  app_service_id = var.resource_id
  subnet_id      = var.subnet_id_integration
}

resource "azurerm_private_endpoint" "privateendpoint" {
  name                = local.pe_name
  location            = var.location
  resource_group_name = var.resource_group_name
  subnet_id           = var.subnet_id_private

  tags = local.merged_tags

  private_service_connection {
    name                           = local.psc_name
    private_connection_resource_id = var.resource_id
    subresource_names              = var.subresources
    is_manual_connection           = false
  }

  timeouts {
    create = var.timeout_create
    update = var.timeout_update
    delete = var.timeout_delete
  }
}


Search service
locals {
  location_abbreviations = {
    eastus         = "eu1"
    eastus2        = "eu2"
    westus         = "wu1"
    westus2        = "wu2"
    centralus      = "cus"
    southcentralus = "scu"
  }
  search_service_name     = var.account_name != "" ? var.account_name : "eh${local.location_abbreviations[var.location]}${var.environment}${var.domain}search"
  private_endpoint_name   = "eh${local.location_abbreviations[var.location]}${var.environment}-pe-${var.domain}"
  service_connection_name = "eh${local.location_abbreviations[var.location]}${var.environment}-psc-${var.domain}"
  #dns_zone_group_name     = "eh${local.location_abbreviations[var.location]}${var.environment}-zg-${var.domain}"
  tags = {
    CostCenter         = var.cost_center
    AssetOwner         = var.asset_owner
    BusinessOwner      = var.business_owner
    DataClassification = var.data_classification
    AppName            = var.app_name
    ITSponsor          = var.it_sponsor
    Tier               = var.tier
    AppTeam            = var.app_team
    AppOwner           = var.app_owner
    ServiceNowBA       = var.service_now_ba
    ServiceNowAS       = var.service_now_as
    SecurityReviewID   = var.security_review_id
  }
  merged_tags = merge(local.tags, var.tags)
}
resource "azurerm_search_service" "module" {
  name                          = local.search_service_name
  location                      = var.location
  resource_group_name           = var.resource_group_name
  sku                           = var.sku
  partition_count               = var.partitions
  replica_count                 = var.replicas
  public_network_access_enabled = var.public_network_access_enabled
  tags                          = local.merged_tags

  timeouts {
    create = var.timeout_create
    update = var.timeout_update
    delete = var.timeout_delete
  }

  identity {
    type = "SystemAssigned"
  }
}

resource "azurerm_private_endpoint" "search_endpoint" {
  count               = var.public_network_access_enabled ? 0 : 1
  location            = var.location
  name                = local.private_endpoint_name
  resource_group_name = var.resource_group_name
  subnet_id           = var.subnet_id
  tags                = local.merged_tags

  timeouts {
    create = var.timeout_create
    update = var.timeout_update
    delete = var.timeout_delete
  }

  private_service_connection {
    name                           = local.service_connection_name
    is_manual_connection           = false
    private_connection_resource_id = azurerm_search_service.module.id
    subresource_names              = ["searchService"]
  }
}

locals {
  location_abbreviations = {
    eastus         = "eu1"
    eastus2        = "eu2"
    westus         = "wu1"
    westus2        = "wu2"
    centralus      = "cus"
    southcentralus = "scu"
  }
  name                    = var.account_name != "" ? var.account_name : "eh${local.location_abbreviations[var.location]}${var.environment}cdb${var.product}${var.domain}"
  capabilities            = var.serverless ? [{ name = "EnableServerless" }] : []
  default_ip_range_filter = "198.27.9.0/24,199.204.156.0/22"
  ip_range_portal         = var.enable_azure_portal_access ? "${local.default_ip_range_filter},104.42.195.92,40.76.54.131,52.176.6.30,52.169.50.45,52.187.184.26" : local.default_ip_range_filter
  ip_range_filter         = var.enable_azure_dc_access ? "${local.ip_range_portal},0.0.0.0" : local.ip_range_portal
  key_vault_key_id        = var.key_vault_key_id != null ? var.key_vault_key_id : null
  tags = {
    CostCenter              = var.cost_center
    AssetOwner              = var.asset_owner
    BusinessOwner           = var.business_owner
    DataClassification      = var.data_classification
    AppName                 = var.app_name
    ITSponsor               = var.it_sponsor
    Tier                    = var.tier
    AppTeam                 = var.app_team
    AppOwner                = var.app_owner
    ServiceNowBA            = var.service_now_ba
    ServiceNowAS            = var.service_now_as
    SecurityReviewID        = var.security_review_id 
    AppCategory             = var.app_category
    DataSubjectArea         = var.data_subject_area
    ComplianceDataCategory  = var.compliance_data_category
    BusinessEntity          = var.business_entity
    LineOfBusiness          = var.line_of_business  
  }
  merged_tags = merge(local.tags, var.tags)
}

resource "azurerm_cosmosdb_account" "module" {
  name                            = local.name
  location                        = var.location
  resource_group_name             = var.resource_group_name
  offer_type                      = var.offer_type
  kind                            = var.kind
  enable_multiple_write_locations = var.enable_multiple_write_locations

  public_network_access_enabled     = true
  ip_range_filter                   = local.ip_range_filter
  is_virtual_network_filter_enabled = length(var.vnet_subnets) > 0 ? true : false
  key_vault_key_id                  = local.key_vault_key_id

  consistency_policy {
    consistency_level       = var.consistency_level
    max_interval_in_seconds = var.max_interval_in_seconds
    max_staleness_prefix    = var.max_staleness_prefix
  }

  enable_automatic_failover = var.enable_automatic_failover

  geo_location {
    location          = var.location
    failover_priority = 0
  }

  dynamic "capabilities" {
    for_each = local.capabilities

    content {
      name = capabilities.value.name
    }
  }

  dynamic "virtual_network_rule" {
    for_each = var.vnet_subnets

    content {
      id = virtual_network_rule.value
    }
  }

  dynamic "geo_location" {
    for_each = var.failover_geo_locations

    content {
      location          = geo_location.value.location
      failover_priority = geo_location.value.failover_priority
    }
  }

  tags = local.merged_tags

  identity {
    type = "SystemAssigned"
  }

  access_key_metadata_writes_enabled= var.enable_access_key_metadata_writes
}

resource "azurerm_monitor_metric_alert" "cosmos_ru_warn" {
  name                = "${local.name}-ru-alert-warn"
  resource_group_name = var.resource_group_name

  scopes = [azurerm_cosmosdb_account.module.id]
  dynamic "action" {
    for_each = var.monitor_action_group_id
    content {
        action_group_id = action.value
    }
  }

  tags = local.merged_tags
  window_size = "PT15M"

  criteria {
    metric_namespace = "Microsoft.DocumentDB/databaseAccounts"
    metric_name      = "NormalizedRUConsumption"
    aggregation      = "Average"
    operator         = "GreaterThan"
    threshold        = 70
  }

  severity = 2
}

resource "azurerm_monitor_metric_alert" "cosmos_ru_error" {
  name                = "${local.name}-ru-alert-error"
  resource_group_name = var.resource_group_name

  scopes = [azurerm_cosmosdb_account.module.id]
 dynamic "action" {
    for_each = var.monitor_action_group_id
    content {
        action_group_id = action.value
    }
  }

  tags = local.merged_tags
  window_size = "PT15M"

  criteria {
    metric_namespace = "Microsoft.DocumentDB/databaseAccounts"
    metric_name      = "NormalizedRUConsumption"
    aggregation      = "Average"
    operator         = "GreaterThan"
    threshold        = 90
  }

  severity = 1
}

resource "azurerm_monitor_metric_alert" "cosmos_ru_critical" {
  name                = "${local.name}-ru-alert-critical"
  resource_group_name = var.resource_group_name

  scopes = [azurerm_cosmosdb_account.module.id]
 dynamic "action" {
    for_each = var.monitor_action_group_id
    content {
        action_group_id = action.value
    }
  }

  tags = local.merged_tags
  window_size = "PT15M"

  criteria {
    metric_namespace = "Microsoft.DocumentDB/databaseAccounts"
    metric_name      = "NormalizedRUConsumption"
    aggregation      = "Average"
    operator         = "GreaterThan"
    threshold        = 99
  }

  severity = 0
}

resource "azurerm_monitor_metric_alert" "cosmos_request_latency" {
  name                = "${local.name}-request-latency-alert"
  resource_group_name = var.resource_group_name
  scopes              = [azurerm_cosmosdb_account.module.id]

  dynamic_criteria {
    metric_namespace  = "Microsoft.DocumentDB/DatabaseAccounts"
    metric_name       = "ServerSideLatency"
    aggregation       = "Average"
    operator          = "GreaterThan"
    alert_sensitivity = var.latency_alert_settings.alert_sensitivity
  }

 dynamic "action" {
    for_each = var.monitor_action_group_id
    content {
        action_group_id = action.value
    }
  }

  frequency   = var.latency_alert_settings.frequency
  window_size = var.latency_alert_settings.window_size
  severity    = var.latency_alert_settings.severity
  tags        = local.merged_tags
}

resource "azurerm_monitor_metric_alert" "cosmos_service_timeout" {
  name                = "${local.name}-alert-service-timeout"
  resource_group_name = var.resource_group_name

  scopes = [azurerm_cosmosdb_account.module.id]
 
 dynamic "action" {
    for_each = var.monitor_action_group_id
    content {
        action_group_id = action.value
    }
  }
  tags = local.merged_tags
 
  window_size = var.service_timeout_setting.window_size
  frequency = var.service_timeout_setting.frequency

  criteria {
    metric_namespace = "Microsoft.DocumentDB/databaseAccounts"
    metric_name      = "TotalRequests"
    aggregation      = "Count"
    operator         = "GreaterThan"
    threshold        = var.service_timeout_setting.threshold
    dimension {
      name ="StatusCode"
      operator = "Include"
      values =["408"] # 408 Service time out
    }
  }
  description = "Alert triggerd when cosmos DB service status 408  i.e Service Time out"

  severity = var.service_timeout_setting.severity
}

resource "azurerm_monitor_metric_alert" "cosmos_service_availability" {
  name                = "${local.name}-alert-service-availability"
  resource_group_name = var.resource_group_name

  scopes = [azurerm_cosmosdb_account.module.id]
 

dynamic "action" {
    for_each = var.monitor_action_group_id
    content {
        action_group_id = action.value
    }
  }
  tags = local.merged_tags

  window_size = var.service_availability_setting.window_size
  frequency = var.service_availability_setting.frequency
dynamic_criteria {
  metric_namespace = "Microsoft.DocumentDB/databaseAccounts"
    metric_name      = "ServiceAvailability"
    aggregation      = "Average"
    operator         = "LessThan"
    alert_sensitivity = "High"
}
  
  description = "Alert triggerd when cosmos DB service availability less than 100% on average "

  severity = var.service_availability_setting.severity
}




Thanks and Regards
Siraj

From: R, Sirajudeen (CTR) 
Sent: Thursday, August 22, 2024 10:40 AM
To: R, Sirajudeen (CTR) <sirajudeen.r@evicore.com>
Subject: azfnctrig



Thanks and Regards
Siraj

