Deadletter
{
    "id": "137e4acc-23d1-489a-9cd7-f3da8fa833b3",
    "EventVersion": null,
    "EventName": null,
    "TopicName": "XPLErssCaseEnrichedIone",
    "Message": "{\"EpisodeID\":\"A178091685\",\"CallerName\":\"epaautomation\",\"EpisodeDate\":\"2023-01-23T05:27:35\",\"CaseNumber\":\"1171859504\",\"HealthPlan\":\"OXFORD\",\"ProcedureCode\":\"70480\",\"PrimaryDiagnosisCode\":\"R10.0\",\"SecondaryDiagnosisCode\":\"\",\"RequestedDateOfService\":\"2023-01-25T00:00:00\",\"AuthorizationStatus\":\"N\",\"CasePriority\":\"R\",\"LastModifiedByUsername\":\"epaautomation\",\"ExpirationDate\":\"0001-01-01T00:00:00\",\"CompanyID\":3,\"LastModifiedDate\":\"2023-01-23T05:27:35\",\"ApprovalDate\":\"0001-01-01T00:00:00\",\"InsertingApplicationID\":11,\"MethodOfContact\":7,\"PlaceOfService\":\"\",\"ReExportFlag\":\"Y\",\"ReasonCode\":\"\",\"ReasonCodeDescription\":\"\",\"Modality\":\"002\",\"InsPlanCode\":\"COMMERCIAL\",\"DueDate\":\"2023-01-25T05:27:35\",\"PhysicianCalled\":\"P\",\"DecisionDate\":\"0001-01-01T00:00:00\",\"RetroReviewFlag\":false,\"ProviderDenialLanguage\":\"\",\"MemberDenialLanguage\":\"\",\"PhysQLOB\":\"COMMERCIAL-FULL\",\"ProcedureName\":\"CT ORBIT W/O CONTRAST\",\"Patient\":{\"Address\":{\"AddressLine1\":\"981 NEITZEL ST\",\"AddressLine2\":\"\",\"City\":\"YAPHANK\",\"State\":\"NY\",\"ZipCode\":\"11980\",\"Country\":null},\"LanguageCode\":\"\",\"PatientId\":\"010166686\",\"OAOID\":\"512750506\",\"FirstName\":\"TANNER\",\"MiddleName\":\"\",\"LastName\":\"CHARBONNEAUX\",\"DateOfBirth\":\"1993-07-08T00:00:00\",\"Sex\":\"F\",\"Phone\":\"000000000\",\"MemberCode\":\"00\",\"GroupNumber\":\"1307228\",\"LineofBusiness\":\"\",\"Category\":\"\",\"PlanType\":\"A\",\"IPACode\":\"FP\",\"Entity\":\"\",\"PlanCode\":\"ANY\",\"EmailAddress\":\"\",\"CellPhone\":\"\",\"JurisdictionState\":\"NY\",\"MemberStartDate\":\"2021-07-01T00:00:00\",\"PatientPUSRDF\":\"\",\"ExchangeID\":\"Not Found\"},\"Physician\":{\"Address\":{\"AddressLine1\":\"701 6TH ST S\",\"AddressLine2\":\"GALTER PAVILION\",\"City\":\"SAINT PETERSBURG\",\"State\":\"FL\",\"ZipCode\":\"33701\",\"Country\":null},\"Phone\":\"(555) 555-5555\",\"Fax\":\"(555) 555-5555\",\"OAOID\":\"R00000\",\"NonParticipating\":false,\"FirstName\":\"BILL\",\"LastName\":\"EVANS\",\"PhysicianHealthPlanID\":\"\",\"Specialty1\":\"REFR-UNKSP\",\"Specialty2\":\"REFR-UNKSP\",\"NonParPhysicianID\":\"\",\"AlternatePhysicianHealthPlanID\":\"\",\"NPI\":\"1215044540\",\"EmailAddress\":\"\",\"CellPhone\":\"\"},\"Site\":null,\"Providers\":[{\"ProviderType\":\"Servicing\",\"ProviderName\":\"PROVIDENCE IMAGING CNSLTNTS\",\"NPI\":\"1659469344\",\"AlternateProviderID\":\"742514106\",\"Address\":{\"AddressLine1\":\"3280 JOE BATTLE BLVD\",\"AddressLine2\":\"\",\"City\":\"EL PASO\",\"State\":\"TX\",\"ZipCode\":\"79938\",\"Country\":null},\"Phone\":\"9158322000\",\"Fax\":\"\",\"Email\":\"\",\"OAOID\":\"063BL0\",\"Participating\":false,\"Specialty1\":\"SITE-CRICR\",\"Specialty2\":\"\",\"NonParProviderID\":\"\",\"SteerageFlag\":2,\"SitePUSRDF\":\"\",\"SiteIPA\":\"\",\"SiteEntity\":\"\"}],\"CaseBasket\":{\"CaseBasketID\":202446735,\"CaseBasketInitialID\":0,\"CreatedDate\":\"2023-01-23T05:27:40.237\",\"CreatedUser\":\"epa\",\"CurrentIndicator\":true,\"DecisionCode\":\"\",\"DecisionNote\":\"\",\"CaseBasketTreatments\":[{\"AmtApproved\":1,\"AmtRequested\":1,\"AuthorizedStartDate\":\"2023-01-23T00:00:00\",\"CaseBasketID\":202446735,\"PlaceOfServiceId\":10,\"PlaceOfServiceCode\":\"11\",\"PlaceOfServiceDescription\":\"Office\",\"TypeOfServiceId\":2,\"TypeOfServiceCode\":\"1\",\"TypeOfServiceDescription\":\"Medical Care\",\"CaseBasketTreatmentID\":202084929,\"CaseBasketTreatmentInitialID\":0,\"TreatmentStatus\":\"Denied\",\"GoalLengthOfStay\":0,\"TreatmentStatusID\":2,\"VisitsRequested\":1,\"VisitsApproved\":0,\"RequestedStartDate\":\"2023-01-23T00:00:00\",\"ExpirationDate\":\"0001-01-01T00:00:00\",\"CurrentIndicator\":true,\"LastModifiedBy\":\"epa\",\"LastModified\":\"2023-01-23T05:27:40.243\",\"QtyUOM\":\"Unit\",\"CaseBasketTreatmentProcedures\":[{\"ProcedureCode\":\"70480\",\"CodeDescription\":\"Computed Tomography (CT), a special kind of picture of your orbits (eyes), sella (bony area behind the eye), or outer, mid, and inner ear without contrast (dye)\",\"ProcedureCodeSetID\":3,\"AmtApproved\":0,\"AmtRemaining\":0,\"AmtRequested\":1,\"IsApproved\":0,\"Qty\":1,\"MedicalProcedureKey\":\"be0afbf6-67d7-4135-b64c-aabadb82e403\",\"CurrentIndicator\":true,\"EnteredBy\":\"\",\"EnteredOn\":\"2023-01-23T05:27:40.283\",\"ExpirationDate\":\"2023-01-23T00:00:00\",\"ProcedureID\":260942,\"SequenceNumber\":1,\"ServiceStatus\":\"\",\"TreatmentStatusID\":0,\"QtyUOM\":\"\",\"CaseBasketTreatmentID\":202084929,\"CaseBasketTreatmentProcedureId\":235414402}]}]},\"ServiceRequestDiagnosis\":[{\"DiagnosisKey\":\"203dbb60-e2db-4357-a8da-96959bc2a67f\",\"DiagnosisPosition\":1,\"DiagnosisCode\":\"R10.0\",\"DiagnosisID\":58170,\"DiagnosisDescription\":\"\",\"FormattedDiagnosisCode\":\"R10.0\",\"DiagnosisIDCodeSetKey\":\"7c29c379-b8c3-47d6-9d67-47747d494286\",\"DiagnosisCodeSetName\":\"ICD10\"}],\"CaseRouting\":{\"CreatedID\":\"epaautomation\",\"MethodOfContactID\":7,\"CaseFactor\":0,\"QueueTag\":0},\"PlanOfCare\":null,\"PreviousAuthStatus\":\"N\",\"HStatusCode\":\"\",\"FaxAttached\":\"0\",\"MarsName\":\"HEAD NEURO\",\"AltRecCPTCode\":\"\",\"OCRConversion\":false,\"MessageKey\":\"81305e92-3cef-40e9-a28c-88ddb2dfc7ed\",\"Publisher\":\"CCN.CaseManagement.PhysicianDecisionTool\",\"PublishedDate\":\"2023-01-23T10:27:40.4072574+00:00\",\"SECEventMessageKey\":\"5fdfb909-8c38-45b0-adf2-ae7ef4f9d0af\",\"EventName\":\"CaseSaved\",\"VersionNumber\":\"2.2\",\"MessageType\":\"CaseSaved\",\"MessageFidelity\":\"\"}",
    "ExceptionMetadata": {
        "Type": "CosmosException",
        "Message": "Response status code does not indicate success: ServiceUnavailable (503); Substatus: 20001; ActivityId: f69dcce0-68ce-4ed6-9141-2512e5aa9294; Reason: (Service is currently unavailable. More info: https://aka.ms/cosmosdb-tsg-service-unavailable. The SDK failed to connect to the service. Please check your networking configuration.\r\nActivityId: f69dcce0-68ce-4ed6-9141-2512e5aa9294, Microsoft.Azure.Cosmos.Tracing.TraceData.ClientSideRequestStatisticsTraceDatum, Windows/10.0.17763 cosmos-netstandard-sdk/3.18.0, Microsoft.Azure.Cosmos.Tracing.TraceData.ClientSideRequestStatisticsTraceDatum, Linux/3.17.1 cosmos-netstandard-sdk/3.29.4);; Diagnostics:{\"Summary\":{\"GatewayCalls\":{\"(503, 20001)\":1}},\"name\":\"CreateItemAsync\",\"id\":\"7cb5bd6c-89f3-4cfe-826c-2f37c3f30f31\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":30146.2061,\"data\":{\"Client Configuration\":{\"Client Created Time Utc\":\"2023-01-21T05:10:15.2124419Z\",\"MachineId\":\"hashedMachineName:7948f3db-b004-32e9-5dd9-30c07395d5b2\",\"NumberOfClientsCreated\":5,\"NumberOfActiveClients\":5,\"ConnectionMode\":\"Gateway\",\"User Agent\":\"cosmos-netstandard-sdk/3.31.2|1|X64|Linux 5.4.0-1098-azure 104 18|.NET 7.0.2|N|\",\"ConnectionConfig\":{\"gw\":\"(cps:50, urto:10, p:False, httpf: False)\",\"rntbd\":\"(cto: 5, icto: -1, mrpc: 30, mcpe: 65535, erd: True, pr: ReuseUnicastPort)\",\"other\":\"(ed:False, be:False)\"},\"ConsistencyConfig\":\"(consistency: NotSet, prgns:[], apprgn: )\",\"ProcessorCount\":1}},\"children\":[{\"name\":\"ItemSerialize\",\"id\":\"f5562bc0-e7bb-459a-b0e9-e063f3e69afd\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":0.1473},{\"name\":\"Microsoft.Azure.Cosmos.Handlers.RequestInvokerHandler\",\"id\":\"4710e4e6-e1ca-4cbb-ad35-29b85e863fdf\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":30145.8041,\"children\":[{\"name\":\"Microsoft.Azure.Cosmos.Handlers.DiagnosticsHandler\",\"id\":\"212051d4-7706-4bf2-baed-09224ae15a9e\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":30145.7792,\"data\":{\"System Info\":{\"systemHistory\":[{\"dateUtc\":\"2023-01-23T10:27:49.1981778Z\",\"cpu\":11.009,\"memory\":1780076.000,\"threadInfo\":{\"isThreadStarving\":\"False\",\"threadWaitIntervalInMs\":0.2588,\"availableThreads\":32761,\"minThreads\":1,\"maxThreads\":32767},\"numberOfOpenTcpConnection\":0},{\"dateUtc\":\"2023-01-23T10:27:59.1985200Z\",\"cpu\":9.119,\"memory\":1780348.000,\"threadInfo\":{\"isThreadStarving\":\"False\",\"threadWaitIntervalInMs\":0.2884,\"availableThreads\":32761,\"minThreads\":1,\"maxThreads\":32767},\"numberOfOpenTcpConnection\":0},{\"dateUtc\":\"2023-01-23T10:28:09.1988395Z\",\"cpu\":8.850,\"memory\":1780612.000,\"threadInfo\":{\"isThreadStarving\":\"False\",\"threadWaitIntervalInMs\":0.2615,\"availableThreads\":32761,\"minThreads\":1,\"maxThreads\":32767},\"numberOfOpenTcpConnection\":0},{\"dateUtc\":\"2023-01-23T10:28:19.1991489Z\",\"cpu\":16.633,\"memory\":1786372.000,\"threadInfo\":{\"isThreadStarving\":\"False\",\"threadWaitIntervalInMs\":0.2318,\"availableThreads\":32761,\"minThreads\":1,\"maxThreads\":32767},\"numberOfOpenTcpConnection\":0},{\"dateUtc\":\"2023-01-23T10:28:29.1995588Z\",\"cpu\":11.054,\"memory\":1786180.000,\"threadInfo\":{\"isThreadStarving\":\"False\",\"threadWaitIntervalInMs\":0.237,\"availableThreads\":32761,\"minThreads\":1,\"maxThreads\":32767},\"numberOfOpenTcpConnection\":0},{\"dateUtc\":\"2023-01-23T10:28:39.1998623Z\",\"cpu\":9.625,\"memory\":1785740.000,\"threadInfo\":{\"isThreadStarving\":\"False\",\"threadWaitIntervalInMs\":0.2333,\"availableThreads\":32761,\"minThreads\":1,\"maxThreads\":32767},\"numberOfOpenTcpConnection\":0}]}},\"children\":[{\"name\":\"Microsoft.Azure.Cosmos.Handlers.RetryHandler\",\"id\":\"2042874c-56ae-48d2-a390-505e6f60b2be\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":30145.768,\"children\":[{\"name\":\"Microsoft.Azure.Cosmos.Handlers.RouterHandler\",\"id\":\"5c021904-3323-4e92-ad68-6c2e813989cc\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":30144.1803,\"children\":[{\"name\":\"Microsoft.Azure.Cosmos.Handlers.TransportHandler\",\"id\":\"12a570bf-a5ff-4d32-aaf3-a1ae05375448\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":30144.176,\"children\":[{\"name\":\"Microsoft.Azure.Cosmos.GatewayStoreModel Transport Request\",\"id\":\"16cc5316-14ae-4eb0-bc9e-86bebf77f239\",\"start time\":\"10:28:16:692\",\"duration in milliseconds\":30138.2996,\"data\":{\"Client Side Request Stats\":{\"Id\":\"AggregatedClientSideRequestStatistics\",\"ContactedReplicas\":[],\"RegionsContacted\":[],\"FailedReplicas\":[],\"AddressResolutionStatistics\":[],\"StoreResponseStatistics\":[],\"HttpResponseStats\":[{\"StartTimeUTC\":\"2023-01-23T10:28:16.6924862Z\",\"DurationInMs\":30124.2632,\"RequestUri\":\"https://eheu2in1cdbucxaclserviceerss-eastus2.documents.azure.com/dbs/ucxaclserviceerssdb/colls/Qualifier/docs\",\"ResourceType\":\"Document\",\"HttpMethod\":\"POST\",\"ActivityId\":\"f69dcce0-68ce-4ed6-9141-2512e5aa9294\",\"StatusCode\":\"ServiceUnavailable\",\"ReasonPhrase\":\"Service Unavailable\"}]},\"Point Operation Statistics\":{\"Id\":\"PointOperationStatistics\",\"ActivityId\":\"f69dcce0-68ce-4ed6-9141-2512e5aa9294\",\"ResponseTimeUtc\":\"2023-01-23T10:28:46.8360050Z\",\"StatusCode\":503,\"SubStatusCode\":20001,\"RequestCharge\":0,\"RequestUri\":\"dbs/ucxaclserviceerssdb/colls/Qualifier\",\"ErrorMessage\":\"Microsoft.Azure.Documents.DocumentClientException: Service is currently unavailable. More info: https://aka.ms/cosmosdb-tsg-service-unavailable. The SDK failed to connect to the service. Please check your networking configuration.\\r\\nActivityId: f69dcce0-68ce-4ed6-9141-2512e5aa9294, Microsoft.Azure.Cosmos.Tracing.TraceData.ClientSideRequestStatisticsTraceDatum, Windows/10.0.17763 cosmos-netstandard-sdk/3.18.0, Microsoft.Azure.Cosmos.Tracing.TraceData.ClientSideRequestStatisticsTraceDatum, Linux/3.17.1 cosmos-netstandard-sdk/3.29.4\\n   at Microsoft.Azure.Cosmos.GatewayStoreClient.ParseResponseAsync(HttpResponseMessage responseMessage, JsonSerializerSettings serializerSettings, DocumentServiceRequest request)\\n   at Microsoft.Azure.Cosmos.GatewayStoreClient.InvokeAsync(DocumentServiceRequest request, ResourceType resourceType, Uri physicalAddress, CancellationToken cancellationToken)\\n   at Microsoft.Azure.Cosmos.GatewayStoreModel.ProcessMessageAsync(DocumentServiceRequest request, CancellationToken cancellationToken)\\n   at Microsoft.Azure.Cosmos.GatewayStoreModel.ProcessMessageAsync(DocumentServiceRequest request, CancellationToken cancellationToken)\\n   at Microsoft.Azure.Cosmos.Handlers.TransportHandler.ProcessMessageAsync(RequestMessage request, CancellationToken cancellationToken)\\n   at Microsoft.Azure.Cosmos.Handlers.TransportHandler.SendAsync(RequestMessage request, CancellationToken cancellationToken)\",\"RequestSessionToken\":null,\"ResponseSessionToken\":null,\"BELatencyInMs\":null}}}]}]}]}]}]}]}",
        "StackTrace": "   at Microsoft.Azure.Cosmos.GatewayStoreClient.ParseResponseAsync(HttpResponseMessage responseMessage, JsonSerializerSettings serializerSettings, DocumentServiceRequest request)\n   at Microsoft.Azure.Cosmos.GatewayStoreClient.InvokeAsync(DocumentServiceRequest request, ResourceType resourceType, Uri physicalAddress, CancellationToken cancellationToken)\n   at Microsoft.Azure.Cosmos.GatewayStoreModel.ProcessMessageAsync(DocumentServiceRequest request, CancellationToken cancellationToken)\n   at Microsoft.Azure.Cosmos.GatewayStoreModel.ProcessMessageAsync(DocumentServiceRequest request, CancellationToken cancellationToken)\n   at Microsoft.Azure.Cosmos.Handlers.TransportHandler.ProcessMessageAsync(RequestMessage request, CancellationToken cancellationToken)\n   at Microsoft.Azure.Cosmos.Handlers.TransportHandler.SendAsync(RequestMessage request, CancellationToken cancellationToken)"
    },
    "DateTime": "2023-01-23T10:28:46.9030161+00:00",
    "Offset": 443886,
    "Partition": 2,
    "Status": 0,
    "Description": "",
    "_rid": "K7MCALgB2oQBAAAAAAAAAA==",
    "_self": "dbs/K7MCAA==/colls/K7MCALgB2oQ=/docs/K7MCALgB2oQBAAAAAAAAAA==/",
    "_etag": "\"0b0098a6-0000-0200-0000-63ce615f0000\"",
    "_attachments": "attachments/",
    "_ts": 1674469727
}
Auditlog
{
    "id": "4f001daa-08e4-04bf-7383-2c59200c8bde",
    "eventSent": "2023-08-11T23:55:15.5997388+00:00",
    "messageKey": "4f001daa-08e4-04bf-7383-2c59200c8bde",
    "lookupKey": "A178101341",
    "version": "1.1.0",
    "messageName": "UCXDueDateCalculated",
    "eventReceivedMessageKey": "ec1a99d3-d90e-4462-84fd-0391ecb7f14e",
    "eventReceivedMessageVersion": null,
    "_rid": "K7MCAOx1AuEBAAAAAAAAAA==",
    "_self": "dbs/K7MCAA==/colls/K7MCAOx1AuE=/docs/K7MCAOx1AuEBAAAAAAAAAA==/",
    "_etag": "\"0700ef39-0000-0200-0000-64d6ca630000\"",
    "_attachments": "attachments/",
    "_ts": 1691798115
}
State
{
    "requestForServiceId": "A178101335",
    "requestForServiceKey": "e7079f72-3cf8-b1ba-1924-b9089162d7d1",
    "secondaryRequestId": null,
    "authorizationKey": "00000000-0000-0000-0000-000000000000",
    "receivedEnriched": false,
    "receivedFinal": false,
    "outcome": null,
    "previousOutcome": null,
    "reasonCode": null,
    "reasonCodeDescription": null,
    "outcomeChangeUserId": null,
    "isImageOneQualifiersUpdatedReadyToBeSent": false,
    "isUcxRequestForServiceSubmittedDirty": false,
    "isRequestForServiceSubmittedSent": false,
    "isRequestLineOfBusinessUpdatedDirty": false,
    "isJurisdictionStateUpdatedDirty": false,
    "isDueDateCalculatedNeeded": false,
    "isDueDateMissedNeeded": false,
    "isRequestUrgencyUpdatedNeeded": false,
    "isExternalSystemStatusChange": false,
    "isRequestSpecialtyUpdatedNeeded": false,
    "imageOneQualifiersUpdated": {
        "version": "1.4.0",
        "name": "UcxImageOneQualifiersUpdated",
        "requestForServiceKey": "e7079f72-3cf8-b1ba-1924-b9089162d7d1",
        "requestForServiceId": "A178101335",
        "authorizationKey": "00000000-0000-0000-0000-000000000000",
        "authorizationId": null,
        "authStatus": null,
        "caseStartDate": "02/05/2023",
        "clientSystem": "IOne",
        "companyId": "Radiology",
        "cptCode": "71270",
        "cptDescription": "CT THORAX W/O & W/ CONTRAST",
        "dueDate": "02/08/2023",
        "episodeId": "A178101335",
        "expirationDate": "NONE",
        "groupNumber": "1418092",
        "holdExpired": "No",
        "icd9Code": "H90.3",
        "icd9Code2": "NONE",
        "insCarrier": null,
        "insPlanCode": "COMMERCIAL",
        "insPlanType": null,
        "patientPlanCode": null,
        "patientPlanType": null,
        "jurisdictionState": "NJ",
        "lockedBy": "NONE",
        "lockedTitle": "NONE",
        "noSiteSelectionRequired": "NONE",
        "npi": "1164478152",
        "patientState": "NJ",
        "physicianSpecialty": "UNKNOWN SPECIALTY",
        "physSpec1": null,
        "physState": "NJ",
        "pos": "11",
        "priority": "R",
        "requestedDos": "02/05/2023",
        "siteNpi": "NONE",
        "siteSpec1": null,
        "specialty": "NONE",
        "workableByOffShore": "1",
        "patientMemberCode": "00",
        "isBasketDefined": null,
        "approvedDate": null,
        "mdSignOffEligible": "NONE",
        "requestFullClinical": "No",
        "mdDecision": "NONE",
        "approvalInterval": "NONE",
        "approvalLanguage": "NONE",
        "approvalLanguageFromPathway": "NONE",
        "approvedServices": "NONE",
        "clientConfig": "0",
        "denialReasonDetailsId": "NONE",
        "deniedServices": "NONE",
        "nltDate": "NONE",
        "groupDxExclusion": "NONE",
        "pathwayAuthStatus": "NONE",
        "requestedServices": "NONE",
        "waiver": "NONE",
        "caseNote": "NotFound",
        "authIndicator": "NotFound",
        "denialLanguage": "NONE",
        "denialLanguageFromPathway": "NONE",
        "denialReasonCode": "NONE",
        "providerDenialLanguage": "NONE",
        "foreignDenialLanguage": "NONE",
        "holdStatusCode": "NONE",
        "altRecCptCode": null,
        "erisa": "N",
        "fullyInsured": null,
        "categoryCode": null,
        "codEpisodeDate": null,
        "memberEntity": null,
        "memberIpa": null,
        "memberOonBenefits": null,
        "modality": null,
        "caseInitiationMethod": null,
        "oaoSiteId": null,
        "caseNumber": null,
        "ssNum": null,
        "steerage": null,
        "patientPusrdf": null,
        "socIndicator": null,
        "isFaxAttached": null,
        "mars": null,
        "ocrConversion": null,
        "exchangeId": "NONE",
        "webClinicalUpload": null,
        "cptCodes": [
            "71270"
        ],
        "entityMatch": null,
        "appealDate": null,
        "hpcphpPlaceOfService": null,
        "hpcphpSteerage": null,
        "siteNetworkStatus": null,
        "tieredNetworkValue": null,
        "selectableYN": null,
        "siteSelectionMethod": null,
        "patientZip": null,
        "providerType": null,
        "siteEntity": null,
        "key": "00000000-0000-0000-0000-000000000000",
        "sent": "2024-05-17T17:16:30.9758603Z",
        "originSystem": "IOne",
        "eventSystem": "ImageOne"
    },
    "ucxRequestForServiceSubmitted": {
        "version": "1.5.0",
        "name": "UCXRequestForServiceSubmitted",
        "requestForServiceKey": "00000000-0000-0000-0000-000000000000",
        "secondaryRequestId": null,
        "authorizationKey": "00000000-0000-0000-0000-000000000000",
        "requestForServiceId": null,
        "submittedProcedureCodes": null,
        "diagnoses": null,
        "medicalDiscipline": null,
        "dateOfService": "0001-01-01T00:00:00",
        "startDate": "0001-01-01T00:00:00",
        "isUrgent": false,
        "memberPolicy": null,
        "providers": null,
        "requestedServices": null,
        "originStatus": null,
        "submittedDate": null,
        "requestType": null,
        "serviceCode": null,
        "serviceCodeDescription": null,
        "requestSpecialty": null,
        "key": "00000000-0000-0000-0000-000000000000",
        "sent": "2024-05-17T17:16:30.9758623Z",
        "originSystem": "",
        "eventSystem": "Unknown"
    },
    "lineOfBusiness": "COMMERCIAL",
    "oldLineOfBusiness": null,
    "dueDate": "2023-02-08T01:52:05.483+00:00",
    "priority": "R",
    "urgentAttestation": {
        "isUrgent": false,
        "reason": null,
        "generatingAgent": null,
        "generatingAgentContext": null,
        "urgentRequestDate": "0001-01-01T00:00:00"
    },
    "medicalDiscipline": "Radiology",
    "status": "Pending review of additional information received",
    "isProceduresUpdatedDirty": false,
    "isDiagnosesUpdatedDirty": false,
    "isMemberInfoUpdatedForRequestDirty": false,
    "ucxMemberInfoUpdatedForRequest": {
        "version": "1.1.0",
        "requestForServiceKey": "e7079f72-3cf8-b1ba-1924-b9089162d7d1",
        "authorizationKey": "00000000-0000-0000-0000-000000000000",
        "requestForServiceId": "A178101335",
        "memberKey": "00000000-0000-0000-0000-000000000000",
        "memberPolicyKey": "00000000-0000-0000-0000-000000000000",
        "memberPolicyId": "321873622",
        "insuranceCarrierKey": "05efbe96-f727-4c37-9708-7ab8d275712d",
        "insurer": "OXFORD",
        "lineOfBusiness": "COMMERCIAL",
        "firstName": "PREMA",
        "middleName": "",
        "lastName": "CROFF",
        "dateOfBirth": "03/09/1959",
        "addressLine1": "27 SELMI PROMENADE",
        "addressLine2": "",
        "city": "FAIRVIEW",
        "county": null,
        "stateCode": "NJ",
        "zipCode": "07022",
        "countryCode": "USA",
        "jurisdictionState": "NJ",
        "gender": "M",
        "fundingCode": null,
        "erisaIndicator": "N",
        "key": "00000000-0000-0000-0000-000000000000",
        "name": null,
        "sent": "2024-05-17T17:16:31.0467839Z",
        "originSystem": "IOne",
        "eventSystem": "ImageOne"
    },
    "procedures": [
        {
            "code": "71270",
            "description": "Computed tomography (CT) (a special kind of picture) of your chest without and with  contrast (dye)",
            "quantityRequested": 1,
            "quantityApproved": null,
            "startDate": "2023-02-03T00:00:00",
            "endDate": "0001-01-01T05:00:00+00:00",
            "modifier": null
        }
    ],
    "diagnoses": [
        {
            "code": "H90.3",
            "description": "Sensorineural hearing loss, bilateral",
            "codeSetName": "ICD10",
            "formattedCode": "H90.3"
        }
    ],
    "id": "A178101335",
    "rehydrateRequired": false,
    "lastMessageReceivedDate": "2023-02-04T01:52:05.8615851+00:00",
    "_rid": "K7MCAP7uQW4JAAAAAAAAAA==",
    "_self": "dbs/K7MCAA==/colls/K7MCAP7uQW4=/docs/K7MCAP7uQW4JAAAAAAAAAA==/",
    "_etag": "\"3100f748-0000-0200-0000-664790ef0000\"",
    "_attachments": "attachments/",
    "_ts": 1715966191
}
Event source message
{
    "id": "7e1a6b96-d83b-2718-39b4-07ecf1ebe87b",
    "key": "2f71f200-381b-419d-8bb7-4a9d88a73961",
    "payloadType": "XplErssCaseEnrichedIone",
    "sent": "2023-05-08T12:53:40.9286324+00:00",
    "version": "2.2",
    "stateIds": {
        "id": "A190835875",
        "partitionKey": "A190835875"
    },
    "metadata": null,
    "metadataType": null,
    "payload": "{\"EpisodeID\":\"A190835875\",\"CallerName\":\"epaautomation\",\"EpisodeDate\":\"2023-05-08T08:53:34\",\"CaseNumber\":\"1184574659\",\"HealthPlan\":\"UNITEDPCP\",\"ProcedureCode\":\"70496\",\"PrimaryDiagnosisCode\":\"H93.A9\",\"SecondaryDiagnosisCode\":\"\",\"RequestedDateOfService\":\"2023-05-10T00:00:00\",\"AuthorizationStatus\":\"N\",\"CasePriority\":\"R\",\"LastModifiedByUsername\":\"epaautomation\",\"ExpirationDate\":\"0001-01-01T00:00:00\",\"CompanyID\":3,\"LastModifiedDate\":\"2023-05-08T08:53:34\",\"ApprovalDate\":\"0001-01-01T00:00:00\",\"InsertingApplicationID\":11,\"MethodOfContact\":7,\"PlaceOfService\":\"\",\"ReExportFlag\":\"Y\",\"ReasonCode\":\"\",\"ReasonCodeDescription\":\"\",\"Modality\":\"002\",\"InsPlanCode\":\"COMMERCIAL\",\"DueDate\":\"2023-05-10T08:53:34\",\"PhysicianCalled\":\"P\",\"DecisionDate\":\"0001-01-01T00:00:00\",\"RetroReviewFlag\":false,\"ProviderDenialLanguage\":\"\",\"MemberDenialLanguage\":\"\",\"PhysQLOB\":\"COMMERCIAL-FULL\",\"ProcedureName\":\"CT ANGIOGRAPHY HEAD\",\"Patient\":{\"Address\":{\"AddressLine1\":\"38 CORDON ST\",\"AddressLine2\":\"\",\"City\":\"CRYSTAL LAKE\",\"State\":\"IL\",\"ZipCode\":\"60014\",\"Country\":null},\"LanguageCode\":\"\",\"PatientId\":\"448694923\",\"OAOID\":\"582330502\",\"FirstName\":\"DARRICK\",\"MiddleName\":\"\",\"LastName\":\"BUJA\",\"DateOfBirth\":\"1962-10-08T00:00:00\",\"Sex\":\"F\",\"Phone\":\"000000000\",\"MemberCode\":\"\",\"GroupNumber\":\"927711\",\"LineofBusiness\":\"3A2AFPS1YA\",\"Category\":\"\",\"PlanType\":\"G\",\"IPACode\":\"\",\"Entity\":\"050\",\"PlanCode\":\"U08\",\"EmailAddress\":\"\",\"CellPhone\":\"\",\"JurisdictionState\":\"IL\",\"MemberStartDate\":\"2022-05-01T00:00:00\",\"PatientPUSRDF\":\"YYPS1-63N\"},\"Physician\":{\"Address\":{\"AddressLine1\":\"1880 W WINCHESTER RD STE 103\",\"AddressLine2\":\"\",\"City\":\"LIBERTYVILLE\",\"State\":\"IL\",\"ZipCode\":\"60048-5321\",\"Country\":null},\"Phone\":\"(555) 555-5555\",\"Fax\":\"(555) 555-5555\",\"OAOID\":\"R00000\",\"NonParticipating\":false,\"FirstName\":\"SYDNEY\",\"LastName\":\"TARDREW\",\"PhysicianHealthPlanID\":\"\",\"Specialty1\":\"REFR-UNKSP\",\"Specialty2\":\"REFR-UNKSP\",\"NonParPhysicianID\":\"\",\"AlternatePhysicianHealthPlanID\":\"\",\"NPI\":\"1902424054\",\"EmailAddress\":\"\",\"CellPhone\":\"\"},\"Site\":null,\"Providers\":[{\"ProviderType\":\"Servicing\",\"ProviderName\":\"MERCYHEALTH HOSPITAL AND TRAUMA CENTER\",\"NPI\":\"1094598760\",\"AlternateProviderID\":\"\",\"Address\":{\"AddressLine1\":\"1000 MINERAL POINT AVE\",\"AddressLine2\":\"\",\"City\":\"JANESVILLE\",\"State\":\"WI\",\"ZipCode\":\"53548\",\"Country\":null},\"Phone\":\"\",\"Fax\":\"\",\"Email\":\"\",\"OAOID\":\"A00000\",\"Participating\":false,\"Specialty1\":\"ABC\",\"Specialty2\":\"\",\"NonParProviderID\":\"\",\"SteerageFlag\":1,\"SitePUSRDF\":\"INN\",\"SiteIPA\":\"\",\"SiteEntity\":\"\"}],\"CaseBasket\":{\"CaseBasketID\":227272792,\"CaseBasketInitialID\":0,\"CreatedDate\":\"2023-05-08T08:53:40.75\",\"CreatedUser\":\"epa\",\"CurrentIndicator\":true,\"DecisionCode\":\"\",\"DecisionNote\":\"\",\"CaseBasketTreatments\":[{\"AmtApproved\":1,\"AmtRequested\":1,\"AuthorizedStartDate\":\"2023-05-08T00:00:00\",\"CaseBasketID\":227272792,\"PlaceOfServiceId\":10,\"PlaceOfServiceCode\":\"11\",\"PlaceOfServiceDescription\":\"Office\",\"TypeOfServiceId\":2,\"TypeOfServiceCode\":\"1\",\"TypeOfServiceDescription\":\"Medical Care\",\"CaseBasketTreatmentID\":226911844,\"CaseBasketTreatmentInitialID\":0,\"TreatmentStatus\":\"Denied\",\"GoalLengthOfStay\":0,\"TreatmentStatusID\":2,\"VisitsRequested\":1,\"VisitsApproved\":0,\"RequestedStartDate\":\"2023-05-08T00:00:00\",\"ExpirationDate\":\"0001-01-01T00:00:00\",\"CurrentIndicator\":true,\"LastModifiedBy\":\"epa\",\"LastModified\":\"2023-05-08T08:53:40.75\",\"QtyUOM\":\"Unit\",\"CaseBasketTreatmentProcedures\":[{\"ProcedureCode\":\"70496\",\"CodeDescription\":\"Computed tomography angiography (CTA a special kind of  picture of the blood vessels in your head) without and with contrast (dye)\",\"ProcedureCodeSetID\":3,\"AmtApproved\":0,\"AmtRemaining\":0,\"AmtRequested\":1,\"IsApproved\":0,\"Qty\":1,\"MedicalProcedureKey\":\"7189a5e2-96b3-4028-85a5-2eaad3c2f7f4\",\"CurrentIndicator\":true,\"EnteredBy\":\"\",\"EnteredOn\":\"2023-05-08T08:53:40.793\",\"ExpirationDate\":\"2023-05-08T00:00:00\",\"ProcedureID\":456,\"SequenceNumber\":1,\"ServiceStatus\":\"\",\"TreatmentStatusID\":0,\"QtyUOM\":\"\",\"CaseBasketTreatmentID\":226911844,\"CaseBasketTreatmentProcedureId\":264032322}]}]},\"ServiceRequestDiagnosis\":[{\"DiagnosisKey\":\"17b33a09-7496-4924-8dda-5bbea32e92b3\",\"DiagnosisPosition\":1,\"DiagnosisCode\":\"H93.A9\",\"DiagnosisID\":116856,\"DiagnosisDescription\":\"\",\"FormattedDiagnosisCode\":\"H93.A9\",\"DiagnosisIDCodeSetKey\":\"7c29c379-b8c3-47d6-9d67-47747d494286\",\"DiagnosisCodeSetName\":\"ICD10\"}],\"CaseRouting\":{\"CreatedID\":\"epaautomation\",\"MethodOfContactID\":7,\"CaseFactor\":0,\"QueueTag\":0},\"PreviousAuthStatus\":\"N\",\"MessageKey\":\"2f71f200-381b-419d-8bb7-4a9d88a73961\",\"Publisher\":\"CCN.CaseManagement.PhysicianDecisionTool\",\"PublishedDate\":\"2023-05-08T12:53:40.9286324+00:00\",\"SECEventMessageKey\":\"121789ba-d01f-46f7-b221-2e3be8fa6986\",\"EventName\":\"CaseSaved\",\"VersionNumber\":\"2.2\",\"MessageType\":\"CaseSaved\",\"MessageFidelity\":\"\",\"MarsName\":\"HEAD NEURO\",\"OCRConversion\":\"false\",\"AltRecCPTCode\":\"\",\"FaxAttached\":\"0\"}",
    "unprocessable": false,
    "_rid": "K7MCAKCt5+wBAAAAAAAAAA==",
    "_self": "dbs/K7MCAA==/colls/K7MCAKCt5+w=/docs/K7MCAKCt5+wBAAAAAAAAAA==/",
    "_etag": "\"0000a600-0000-0200-0000-64d6ca600000\"",
    "_attachments": "attachments/",
    "_ts": 1691798112
}


Thanks and Regards
Siraj

From: R, Sirajudeen (CTR) 
Sent: Tuesday, August 20, 2024 8:35 PM
To: R, Sirajudeen (CTR) <sirajudeen.r@evicore.com>
Subject: evtsr

using Ardalis.GuardClauses;
using evicore.eventsource.@base.interfaces;
using evicore.eventsource.@base.models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace evicore.eventsource.library.services;

public sealed class EventSourceService<TState> : IEventSourceService<TState> where TState : BaseState
{
    private readonly IDetermineRehydrateRequired<TState> _determineRehydrateRequired;
    private readonly IEventSourceMessageRepository<TState> _eventSourceMessageRepository;
    private readonly ILogger<EventSourceService<TState>> _logger;
    private readonly IPostApplyProcessor<TState> _postApplyProcessor;
    private readonly IPreApplyProcessor<TState> _preApplyProcessor;
    private readonly Dictionary<string, object> _scope;
    private readonly ISortEventSourceMessages _sortingService;
    private readonly IStateBuilder<TState> _stateBuilder;
    private readonly IStateRepository<TState> _stateRepository;

    public EventSourceService(ILogger<EventSourceService<TState>> logger, IStateRepository<TState> stateRepository,
        IEventSourceMessageRepository<TState> eventSourceMessageRepository,
        IStateBuilder<TState> stateBuilder, IDetermineRehydrateRequired<TState>? determineRehydrateRequired = null, IPreApplyProcessor<TState>? preApplyProcessor = null,
        IPostApplyProcessor<TState>? postApplyProcessor = null, ISortEventSourceMessages? sortingService = null)
    {
        _logger = logger;
        _stateRepository = stateRepository;
        _eventSourceMessageRepository = eventSourceMessageRepository;
        _stateBuilder = stateBuilder;
        _determineRehydrateRequired = determineRehydrateRequired ?? new DefaultDetermineRehydrateRequired<TState>();
        _preApplyProcessor = preApplyProcessor ?? new NoOpPreApplyProcessorService<TState>();
        _postApplyProcessor = postApplyProcessor ?? new NoOpPostApplyProcessorService<TState>();
        _sortingService = sortingService ?? new DefaultSortEventSourceMessages();
        _scope = new Dictionary<string, object>
        {
            { "Class", nameof(EventSourceService<TState>) }
        };
    }

    public async Task HandleAsync(EventSourceMessage message)
    {
        ValidateMessage(message);
        var scope = GetScope(message);
        scope["Method"] = "Task HandleAsync(EventSourceMessage message)";
        using (_logger.BeginScope(scope))
        {
            _logger.LogDebug("Starting to handle message");
            _logger.LogDebug("Adding event source message");
            var successfullyAdded = await _eventSourceMessageRepository.TryAddAsync(message);
            if (!successfullyAdded)
            {
                _logger.LogDebug("Message already exists");
                return;
            }

            _logger.LogDebug("Getting state");
            var state = await _stateRepository.GetAsync(message.StateIds);
            if (state is null)
            {
                state = _stateBuilder.Create();
                state.Id = message.StateIds.Id;
            }

            _logger.LogDebug("Determining if rehydrate is required");
            var rehydrateRequired = await _determineRehydrateRequired.GetAsync(state, message);

            if (!rehydrateRequired)
            {
                await ApplyAsync(message, state);
                if (!message.Unprocessable)
                {
                    _logger.LogDebug("Saving state");
                    await _stateRepository.UpsertAsync(state);
                }
                else
                {
                    await _eventSourceMessageRepository.UpdateUnprocessableAsync(true, message.Id, message.StateIds.Id);
                }
            }
            else
            {
                _logger.LogDebug("Getting all event source messages");
                var eventSourceMessages = await _eventSourceMessageRepository.GetAllAsync(message.StateIds.Id);
                state = await RehydrateAsync(eventSourceMessages);
                await _stateRepository.UpsertAsync(state);
            }

            _logger.LogDebug("Completed handling message");
        }
    }

    public async Task<TState> RehydrateAsync(IEnumerable<EventSourceMessage> eventSourceMessages, CancellationToken cancellationToken = default)
    {
        _logger.LogDebug("Sorting event source messages");
        var orderedEvents = await _sortingService.SortAsync(eventSourceMessages, cancellationToken);
        var state = _stateBuilder.Create();
        state.RehydrateRequired = true;
        var messages = orderedEvents.ToList();
        state.Id = messages[0].StateIds.Id;
        _logger.LogDebug("Rehydrating state by applying all messages");
        foreach (var eventSourceMessage in messages)
        {
            var originalUnprocessable = eventSourceMessage.Unprocessable;
            var clonedState = (TState)state.Clone();
            await ApplyAsync(eventSourceMessage, state);
            if (eventSourceMessage.Unprocessable) state = clonedState;

            if (originalUnprocessable != eventSourceMessage.Unprocessable)
                await _eventSourceMessageRepository.UpdateUnprocessableAsync(eventSourceMessage.Unprocessable, eventSourceMessage.Id, eventSourceMessage.StateIds.Id,
                    cancellationToken);
        }

        state.RehydrateRequired = false;
        _logger.LogDebug("Rehydrate complete");
        return state;
    }

    private async Task ApplyAsync(EventSourceMessage message, TState state)
    {
        var scope = GetScope(message);
        scope["Method"] = "Task ApplyAsync(EventSourceMessage message, TState state)";
        using (_logger.BeginScope(scope))
        {
            try
            {
                _logger.LogDebug("Running preApplyProcessor");
                await _preApplyProcessor.ProcessAsync(state, message);
                _logger.LogDebug("Applying message");
                state.Apply(message);
                _logger.LogDebug("Running postApplyProcessor");
                await _postApplyProcessor.ProcessAsync(state, message);
                state.LastMessageReceivedDate = message.Sent;
                message.Unprocessable = false;
            }
            catch (Exception e)
            {
                _logger.LogError(e, "Error applying message");
                message.Unprocessable = true;
            }
        }
    }

    private Dictionary<string, object> GetScope(EventSourceMessage message)
    {
        return new Dictionary<string, object>(_scope)
        {
            { "MessageId", message.Id },
            { "MessageKey", message.Key },
            { "MessagePayloadType", message.PayloadType },
            { "MessageVersion", message.Version },
            { "MessageMetadata", message.Metadata ?? string.Empty },
            { "MessageMetadataType", message.MetadataType ?? string.Empty },
            { "StateId", message.StateIds.Id },
            { "StatePartitionKey", message.StateIds.PartitionKey }
        };
    }

    private static void ValidateMessage(EventSourceMessage message)
    {
        Guard.Against.Null(message);
        Guard.Against.Null(message.StateIds);
        Guard.Against.NullOrWhiteSpace(message.StateIds.Id);
        Guard.Against.NullOrWhiteSpace(message.Payload);
        Guard.Against.Null(message.Key);
        Guard.Against.Default(message.Key);
        Guard.Against.NullOrWhiteSpace(message.PayloadType);
        Guard.Against.Null(message.Sent);
        Guard.Against.Default(message.Sent);
    }

    public static void RegisterDependency(IServiceCollection services)
    {
        services.AddTransient<IEventSourceService<TState>, EventSourceService<TState>>();
    }
}

using evicore.eventsource.@base.models;
using evicore.ucx.patterns.Extensions;
using Newtonsoft.Json;
using ucx.messages.@base;

namespace evicore.eventsource.library.helpers;

public static class EventSourceMessageHelper
{
    public static EventSourceMessage ConvertToEventSourceMessage<T>(T message, StateIds stateIds, string? metadata = null,
        string? metadataType = null) where T : Message
    {
        var jsonMessage = JsonConvert.SerializeObject(message);
        return new EventSourceMessage
        {
            Id = jsonMessage.ConvertToGuid(),
            Key = message.Key.ToString(),
            Version = message.Version,
            Sent = message.Sent.Kind == DateTimeKind.Unspecified ? new DateTimeOffset(message.Sent, TimeSpan.Zero) : new DateTimeOffset(message.Sent),
            Payload = jsonMessage,
            PayloadType = message.GetType().Name,
            StateIds = stateIds,
            Metadata = metadata,
            MetadataType = metadataType
        };
    }

    public static EventSourceMessage ConvertToEventSourceMessage<T>(T message, DateTimeOffset sent, string version, string? key, StateIds stateIds, string? metadata = null,
        string? metadataType = null)
    {
        var jsonMessage = JsonConvert.SerializeObject(message);
        var id = jsonMessage.ConvertToGuid();

        return new EventSourceMessage
        {
            Id = id,
            Key = key ?? id.ToString(),
            Version = version,
            Sent = sent,
            Payload = jsonMessage,
            PayloadType = message!.GetType().Name,
            StateIds = stateIds,
            Metadata = metadata,
            MetadataType = metadataType
        };
    }
}

namespace evicore.eventsource.@base.models;

public abstract class BaseState : ICloneable
{
    public string? Id { get; set; }
    public bool RehydrateRequired { get; set; }
    public DateTimeOffset LastMessageReceivedDate { get; set; }
    public abstract void Apply(EventSourceMessage message);
    public object Clone()
    {
        return (BaseState)this.MemberwiseClone();
    }
}


using System.Text;
using evicore.ucx.patterns.Extensions;

namespace evicore.eventsource.@base.models;

public class EventSourceMessage
{
    public Guid Id { get; set; }
    public string Key { get; set; }
    public string PayloadType { get; set; }
    public DateTimeOffset Sent { get; set; }
    public string Version { get; set; }
    public StateIds StateIds { get; set; }
    public string? Metadata { get; set; }
    public string? MetadataType { get; set; }
    public string Payload { get; set; }
    public bool Unprocessable { get; set; }
}


namespace evicore.eventsource.@base.models;

public record StateIds(string Id, string PartitionKey)
{
}


using evicore.eventsource.@base.interfaces;
using evicore.eventsource.@base.models;
using Microsoft.Extensions.DependencyInjection;

namespace evicore.eventsource.library.builders;

public class StateBuilder<T> : IStateBuilder<T> where T : BaseState, new()
{
    public T Create()
    {
        return new T();
    }

    public static void RegisterDependency(IServiceCollection serviceCollection)
    {
        serviceCollection.AddTransient<IStateBuilder<T>, StateBuilder<T>>();
    }
}


using evicore.eventsource.api.interfaces;
using evicore.eventsource.@base.interfaces;
using evicore.eventsource.@base.models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace evicore.eventsource.api.services;

public class EventSourceControllerService<T> : IEventSourceControllerService<T> where T : BaseState
{
    private readonly IBackgroundWorkerQueue _backgroundWorkerQueue;
    private readonly ILogger<EventSourceControllerService<T>> _logger;
    private readonly IPrepareEventSourceForRehydrate<T> _prepareEventSourceForRehydrate;
    private readonly IRehydrateEventSource<T> _rehydrateEventSource;

    public EventSourceControllerService(ILogger<EventSourceControllerService<T>> logger, IPrepareEventSourceForRehydrate<T>
            prepareEventSourceForRehydrate, IRehydrateEventSource<T> rehydrateEventSource,
        IBackgroundWorkerQueue backgroundWorkerQueue)
    {
        _logger = logger;
        _prepareEventSourceForRehydrate = prepareEventSourceForRehydrate;
        _rehydrateEventSource = rehydrateEventSource;
        _backgroundWorkerQueue = backgroundWorkerQueue;
    }

    public Task RehydratePrepareAll(string? settings = null)
    {
        var scope = new Dictionary<string, object>
        {
            { "Class", nameof(EventSourceControllerService<T>) },
            { "Method", "Task RehydratePrepareAll(string? settings = null)" },
            { "Settings", settings ?? string.Empty }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("Start background worker to prepare all records for rehydrate");
            _backgroundWorkerQueue.QueueBackgroundWorkItem(async _ =>
            {
                await _prepareEventSourceForRehydrate.RehydratePrepareAllAsync(settings);
                _logger.LogInformation("Completed background worker preparing all records for rehydrate");
            });
            return Task.CompletedTask;
        }
    }

    public async Task RehydratePrepare(StateIds stateIds)
    {
        var scope = new Dictionary<string, object>
        {
            { "Class", nameof(EventSourceControllerService<T>) },
            { "Method", "Task RehydratePrepare(StateIds stateIds)" },
            { "StateId", stateIds.Id },
            { "StatePartitionKey", stateIds.PartitionKey }
        };
        using (_logger.BeginScope(scope))
        {
            await _prepareEventSourceForRehydrate.RehydratePrepareAsync(stateIds);
        }
    }

    public Task RehydratePrepare(DateTimeOffset startDate, DateTimeOffset endDate, string? settings = null)
    {
        var scope = new Dictionary<string, object>
        {
            { "Class", nameof(EventSourceControllerService<T>) },
            { "Method", "Task RehydratePrepare(DateTimeOffset startDate, DateTimeOffset endDate, string? settings = null)" },
            { "StartDate", startDate },
            { "EndDate", endDate },
            { "Settings", settings ?? string.Empty }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("Start background worker to prepare records for rehydrate from {startDate} to {endDate}", startDate, endDate);
            _backgroundWorkerQueue.QueueBackgroundWorkItem(async _ =>
            {
                await _prepareEventSourceForRehydrate.RehydratePrepareAsync(startDate, endDate, settings);
                _logger.LogInformation("Completed background worker preparing records for rehydrate from {startDate} to {endDate}", startDate, endDate);
            });
            return Task.CompletedTask;
        }
    }

    public Task RehydrateAll(string? settings = null)
    {
        var scope = new Dictionary<string, object>
        {
            { "Class", nameof(EventSourceControllerService<T>) },
            { "Method", "Task RehydrateAll(RehydrateSettings settings)" },
            { "Settings", settings ?? string.Empty }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("Starting background worker to rehydrate all records");
            _backgroundWorkerQueue.QueueBackgroundWorkItem(async _ =>
            {
                await _rehydrateEventSource.RehydrateAllAsync(settings);
                _logger.LogInformation("Completed background worker rehydrate all records");
            });
        }

        return Task.CompletedTask;
    }

    public async Task Rehydrate(string stateId)
    {
        var scope = new Dictionary<string, object>
        {
            { "Class", nameof(EventSourceControllerService<T>) },
            { "Method", "Task Rehydrate(StateIds stateIds)" },
            { "StateId", stateId }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("Starting rehydrate");
            await _rehydrateEventSource.RehydrateAsync(stateId);
            _logger.LogDebug("Completed rehydrate");
        }
    }

    public static void RegisterDependency(IServiceCollection services)
    {
        services.AddTransient<IEventSourceControllerService<T>, EventSourceControllerService<T>>();
    }
}

trigger:
  branches:
    include:
      - main
pool:
  vmImage: 'ubuntu-latest'
resources:
  repositories:
    - repository: ucxAdoTemplates
      type: git
      name: 'UCX/ucx-ado-templates'
variables:
  buildConfiguration: 'Release'
  projectPath: 'evicore.eventsource.api/evicore.eventsource.api.csproj'
  solutionPath: 'evicore.eventsource.api.sln'
  publishFeed: 'eb6a6b78-0104-45b0-b0e6-03d649a3a686/51c8c92d-0a26-44b7-b6e5-c6f6b8f472e7'
  dotnetVersion: '7.x'
  nugetConfigPath: 'NuGet.Config'
  unitTestProjectPath: 'evicore.eventsource.api.test/evicore.eventsource.api.test.csproj'
stages:
  - stage: BuildAndTest
    jobs:
      - template: dotnet/build-and-test.yaml@ucxAdoTemplates
        parameters:
          dotnetVersion: $(dotnetVersion)
          nugetConfigPath: $(nugetConfigPath)
          solutionPath: $(solutionPath)
          testPath: $(unitTestProjectPath)
  - stage: EditorConfigCheck
    dependsOn: BuildAndTest
    jobs:
      - job:
        steps:
          - template: misc/editor-config-template.yml@ucxAdoTemplates
            parameters:
              pathToCheck: '$(git ls-files)'
  - stage: DeployPackage
    dependsOn: EditorConfigCheck
    jobs:
      - template: dotnet/nuget-pack-and-deploy.yaml@ucxAdoTemplates
        parameters:
          buildConfiguration: $(buildConfiguration)
          projectPath: $(projectPath)
          publishFeed: $(publishFeed)
          solutionPath: $(projectPath)
          nugetConfigPath: $(nugetConfigPath)
          dotnetVersion: $(dotnetVersion)


trigger:
  branches:
    include:
      - main
pool:
  name: ubuntu-latest
resources:
  repositories:
    - repository: ucxAdoTemplates
      type: git
      name: 'UCX/ucx-ado-templates'
variables:
  buildConfiguration: 'Release'
  projectPath: 'ucx.messages.base/ucx.messages.base.csproj'
  solutionPath: 'ucx.messages.base.sln'
  unitTestProjectPath: 'ucx.messages.base.sln'
  publishFeed: 'eb6a6b78-0104-45b0-b0e6-03d649a3a686/51c8c92d-0a26-44b7-b6e5-c6f6b8f472e7'
  dotnetVersion: '7.x'
  nugetConfigPath: 'NuGet.Config'

stages:
  - stage: BuildAndTest
    jobs:
      - template: dotnet/build-and-test.yaml@ucxAdoTemplates
        parameters:
          dotnetVersion: $(dotnetVersion)
          nugetConfigPath: $(nugetConfigPath)
          solutionPath: $(solutionPath)
          testPath: $(unitTestProjectPath)
  - stage: EditorConfigCheck
    dependsOn: BuildAndTest
    jobs:
      - job:
        steps:
          - template: misc/editor-config-template.yml@ucxAdoTemplates
            parameters:
              pathToCheck: '$(git ls-files)'
  - stage: DeployPackage
    jobs:
      - template: dotnet/nuget-pack-and-deploy.yaml@ucxAdoTemplates
        parameters:
          buildConfiguration: $(buildConfiguration)
          projectPath: $(projectPath)
          publishFeed: $(publishFeed)
          solutionPath: $(solutionPath)
          nugetConfigPath: $(nugetConfigPath)
          dotnetVersion: $(dotnetVersion)


nuget-pack-and-deploy.yaml
parameters:
  - name: buildConfiguration
    type: string
  - name: projectPath
    type: string
  - name: publishFeed
    type: string
  - name: solutionPath
    type: string
  - name: nugetConfigPath
    type: string
  - name: dotnetVersion
    type: string
jobs:
  - job: PackAndPush
    timeoutInMinutes: 300
    displayName: "Nuget pack and push"
    steps:
      - download: none
      - checkout: self
      - task: UseDotNet@2
        displayName: 'Install .NET ${{ parameters.dotnetVersion }} SDK'
        inputs:
          packageType: 'sdk'
          version: ${{ parameters.dotnetVersion }}
          performMultiLevelLookup: true
      - task: DotNetCoreCLI@2
        displayName: dotnet restore
        inputs:
          command: 'restore'
          projects: ${{ parameters.solutionPath }}
          feedsToUse: 'config'
          nugetConfigPath: ${{ parameters.nugetConfigPath }}
      - task: DotNetCoreCLI@2
        displayName: "dotnet pack"
        inputs:
          command: 'pack'
          arguments: '--configuration ${{ parameters.buildConfiguration }}'
          packagesToPack: '${{ parameters.projectPath }}'
      - task: NuGetCommand@2
        displayName: 'nuget push'
        inputs:
          command: 'push'
          feedsToUse: 'select'
          packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg;$(Build.ArtifactStagingDirectory)/**/*.snupkg'
          nuGetFeedType: 'internal'
          publishVstsFeed: '${{ parameters.publishFeed }}'
          allowPackageConflicts: true
        

using evicore.eventsource.@base.interfaces;
using evicore.eventsource.@base.models;
using evicore.gravity.common.Interface;
using Microsoft.Azure.Cosmos;
using Microsoft.Extensions.Logging;

namespace evicore.eventsource.cosmos.Implementation;

public class EventSourceMessageRepository<TState> : IEventSourceMessageRepository<TState> where TState : BaseState
{
    private readonly ILogger<EventSourceMessageRepository<TState>> _logger;
    private readonly ICosmosDbService<EventSourceMessageRecord<TState>> _cosmosDb;
    private readonly Dictionary<string, object> _scope;
    public EventSourceMessageRepository(ILogger<EventSourceMessageRepository<TState>> logger, ICosmosDbService<EventSourceMessageRecord<TState>> cosmosDb)
    {
        _logger = logger;
        _cosmosDb = cosmosDb;
        _scope = new Dictionary<string, object>
        {
            { "Class", nameof(EventSourceMessageRepository<TState>) }
        };
    }
    public async Task<IList<EventSourceMessage>> GetAllAsync(string stateId, CancellationToken cancellationToken = default)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task<IList<EventSourceMessage>> GetAllAsync(string stateId, CancellationToken cancellationToken = default)" },
            { "StateId", stateId }
        };
        using (_logger.BeginScope(scope))
        {
            return (IList<EventSourceMessage>)await _cosmosDb.ReadItemsByPartitionKey<EventSourceMessage>(stateId, cancellationToken);
        }
    }

    public async Task<bool> TryAddAsync(EventSourceMessage message, CancellationToken cancellationToken = default)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task<bool> TryAddAsync(EventSourceMessage message)" },
            { "Id", message.Id },
            { "StateId",message.StateIds.Id },
            { "StatePartitionKey", message.StateIds.PartitionKey }
        };
        using (_logger.BeginScope(scope))
        {
            try
            {
                _logger.LogDebug("Fetching to check if EventSourceMessageRecord already exists");
                var existingRecord = await _cosmosDb.ReadItemAsync(message.Id.ToString(), message.StateIds.Id, cancellationToken);
                if (existingRecord != null)
                {
                    _logger.LogDebug("EventSourceMessageRecord already exists");
                    return false;
                }
                _logger.LogDebug("EventSourceMessageRecord does not already exist and now inserting");
                await _cosmosDb.CreateItemAsync(new EventSourceMessageRecord<TState>(message), message.StateIds.Id, cancellationToken);
                _logger.LogDebug("Successfully created EventSourceMessageRecord");
                return true;
            }
            catch (Exception e)
            {
                _logger.LogError(e, "Failed to insert EventSourceMessageRecord");
                return false;
            }
        }
    }

    public async Task UpdateUnprocessableAsync(bool unprocessable, Guid id, string stateId, CancellationToken cancellationToken = default)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task UpdateUnprocessableAsync(bool unprocessable, Guid id, string stateId, CancellationToken cancellationToken = default)" },
            { "PatchUnprocessableId", id },
            { "PatchUnprocessableStateId", stateId },
            { "PatchUnprocessableValue", unprocessable }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogDebug("Patching EventSourceMessageRecord");
            await _cosmosDb.PatchItem(id.ToString(), stateId, new List<PatchOperation>
            {
                PatchOperation.Set("/unprocessable", unprocessable)
            });
            _logger.LogDebug("Successfully patched");
        }
    }
}


using evicore.eventsource.@base.interfaces;
using evicore.eventsource.@base.models;
using evicore.eventsource.cosmos.interfaces;
using evicore.eventsource.cosmos.services;
using evicore.gravity.common.Interface;
using Microsoft.Extensions.Logging;

namespace evicore.eventsource.cosmos.Implementation;

public class StateRepository<TState> : IStateRepository<TState> where TState : BaseState
{
    private readonly ICosmosDbService<TState> _cosmosDb;
    private readonly ILogger<StateRepository<TState>> _logger;
    private readonly Dictionary<string, object> _scope;
    private readonly IGetPartitionKey<TState> ? _getPartitionKey;

    public StateRepository(ILogger<StateRepository<TState>> logger, ICosmosDbService<TState> cosmosDb, IGetPartitionKey<TState>? getPartitionKey = null)
    {
        _logger = logger;
        _cosmosDb = cosmosDb;
        _getPartitionKey = getPartitionKey ?? new DefaultPartitionKeyService<TState>();
        _scope = new Dictionary<string, object>
        {
            { "Class", nameof(StateRepository<TState>) }
        };
    }

    public async Task<TState> UpsertAsync(TState state, CancellationToken cancellationToken = default)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task<TState> UpsertAsync(TState state, StateIds ids, CancellationToken cancellationToken)" },
            { "Id", state.Id },
            { "PartitionKey", _getPartitionKey.Get(state) }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("State handling started");
            return await _cosmosDb.UpsertItemAsync(_ => state, state.Id, _getPartitionKey.Get(state), cancellationToken);
        }

    }

    public async Task<TState?> GetAsync(StateIds ids, CancellationToken cancellationToken = default)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task<TState> GetAsync(StateIds ids, CancellationToken cancellationToken)" },
            { "Id", ids.Id },
            { "PartitionKey", ids.PartitionKey }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("State handling started");
            return await _cosmosDb.ReadItemAsync(ids.Id, ids.PartitionKey, cancellationToken);
        }
    }
}


namespace evicore.eventsource.cosmos.Model;

public class RehydrateSettings
{
    public int ThrottleMs { get; set; } = 0;
    public int TakePerThrottle { get; set; } = 500;
    public bool WhereRehydrateRequiredIsTrue { get; set; } = true;
    public bool MarkRehydrateRequiredAs { get; set; } = true;
}

namespace evicore.eventsource.@base.models;

public class EventSourceMessageRecord<T> : EventSourceMessage where T : BaseState
{
    public EventSourceMessageRecord()
    {

    }
    public EventSourceMessageRecord(EventSourceMessage eventSourceMessage)
    {
        Id = eventSourceMessage.Id;
        Key = eventSourceMessage.Key;
        Metadata = eventSourceMessage.Metadata;
        MetadataType = eventSourceMessage.MetadataType;
        Payload = eventSourceMessage.Payload;
        PayloadType = eventSourceMessage.PayloadType;
        Sent = eventSourceMessage.Sent;
        StateIds = eventSourceMessage.StateIds;
        Unprocessable = eventSourceMessage.Unprocessable;
        Version = eventSourceMessage.Version;
    }

    public EventSourceMessage ConvertToEventSourceMessage()
    {
        return new EventSourceMessage
        {
            Id = Id,
            Key = Key,
            Metadata = Metadata,
            MetadataType = MetadataType,
            Payload = Payload,
            PayloadType = PayloadType,
            Sent = Sent,
            StateIds = StateIds,
            Unprocessable = Unprocessable,
            Version = Version
        };
    }
}

using evicore.eventsource.@base.interfaces;
using evicore.eventsource.@base.models;
using evicore.eventsource.cosmos.interfaces;
using evicore.eventsource.cosmos.Model;
using evicore.gravity.common.Interface;
using Microsoft.Azure.Cosmos;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

namespace evicore.eventsource.cosmos.services;

public class PrepareEventSourceForRehydrateService<TState> : IPrepareEventSourceForRehydrate<TState> where TState : BaseState
{
    private const string SelectAllQuery = "SELECT * FROM c WHERE c.rehydrateRequired = false";
    private const string SelectAllTrueQuery = "SELECT * FROM c WHERE c.rehydrateRequired = true";
    private readonly IGetPartitionKey<TState> _getPartitionKeyService;
    private readonly ILogger<PrepareEventSourceForRehydrateService<TState>> _logger;
    private readonly Dictionary<string, object> _scope;
    private readonly ICosmosDbService<TState> _stateCosmosDbService;
    private readonly ICosmosDbService<EventSourceMessageRecord<TState>> _eventsCosmosDbService;

    public PrepareEventSourceForRehydrateService(ILogger<PrepareEventSourceForRehydrateService<TState>> logger, ICosmosDbService<TState> stateCosmosDbService,
        ICosmosDbService<EventSourceMessageRecord<TState>> eventsCosmosDbService, IGetPartitionKey<TState>? getPartitionKeyService = null)
    {
        _logger = logger;
        _stateCosmosDbService = stateCosmosDbService;
        _eventsCosmosDbService = eventsCosmosDbService;
        _getPartitionKeyService = getPartitionKeyService ?? new DefaultPartitionKeyService<TState>();
        _scope = new Dictionary<string, object>
        {
            { "Class", "PrepareEventSourceForRehydrateService<TState>" }
        };
    }

    public async Task RehydratePrepareAllAsync(string? settings = null)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task RehydratePrepareAllAsync(string? settings = null)" }
        };
        using (_logger.BeginScope(scope))
        {
            var rehydrateSettings = new RehydrateSettings();
            if (settings is not null) rehydrateSettings = JsonConvert.DeserializeObject<RehydrateSettings>(settings)!;

            _logger.LogInformation("Start preparing all records for rehydrate");
            using var feed = _stateCosmosDbService.ReadItems(rehydrateSettings.MarkRehydrateRequiredAs ? SelectAllQuery : SelectAllTrueQuery);
            var overallCount = 0;
            while (feed.HasMoreResults)
            {
                var states = new Queue<TState>();
                var response = await feed.ReadNextAsync();
                _logger.LogDebug("prepare rehydrate RU Cost {RequestCharge}", response.RequestCharge);
                response.ToList().ForEach(item => states.Enqueue(item));
                while (states.Count > 0)
                {
                    overallCount = await RehydratePrepareAllInQueueAsync(rehydrateSettings.TakePerThrottle, states, overallCount, rehydrateSettings.MarkRehydrateRequiredAs);
                    if (states.Count > 0)
                        await Task.Delay(TimeSpan.FromMilliseconds(rehydrateSettings.ThrottleMs));
                }
            }

            _logger.LogInformation("Completed event source update all records with RehydrateRequired as true {OverallCount} records", overallCount);
        }
    }

    private async Task RehydratePrepareAsync(StateIds ids, bool markRehydrateRequiredAs = true)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task RehydratePrepareAsync(StateIds ids)" },
            { "StateId", ids.Id },
            { "StatePartitionKey", ids.PartitionKey }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("Start preparing record for rehydrate");
            await _stateCosmosDbService.PatchItem(ids.Id, ids.PartitionKey, new List<PatchOperation>
            {
                PatchOperation.Set("/rehydrateRequired", markRehydrateRequiredAs)
            });
            _logger.LogInformation("Completed preparing record for rehydrate");
        }
    }

    public async Task RehydratePrepareAsync(StateIds ids)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task RehydratePrepareAsync(StateIds ids)" },
            { "StateId", ids.Id },
            { "StatePartitionKey", ids.PartitionKey }
        };
        using (_logger.BeginScope(scope))
        {
            _logger.LogInformation("Start preparing record for rehydrate");
            await _stateCosmosDbService.PatchItem(ids.Id, ids.PartitionKey, new List<PatchOperation>
            {
                PatchOperation.Set("/rehydrateRequired", true)
            });
            _logger.LogInformation("Completed preparing record for rehydrate");
        }
    }

    public async Task RehydratePrepareAsync(DateTimeOffset startDate, DateTimeOffset endDate, string? settings = null)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task RehydratePrepareAsync(DateTimeOffset startDate, DateTimeOffset endDate, string? settings = null)" }
        };
        using (_logger.BeginScope(scope))
        {
            var rehydrateSettings = new RehydrateSettings();
            if (settings is not null) rehydrateSettings = JsonConvert.DeserializeObject<RehydrateSettings>(settings)!;

            _logger.LogInformation("Start preparing records for rehydrate from {startDate} to {endDate}", startDate, endDate);

            var query = $"SELECT * FROM c WHERE c.sent >= \"{startDate:O}\" and c.sent <= \"{endDate:O}\"";
            using var feed = _eventsCosmosDbService.ReadItems(query);
            var overallCount = 0;
            while (feed.HasMoreResults)
            {
                var response = await feed.ReadNextAsync();
                var stateIds = response.ToList().Select(x => x.StateIds).Distinct().ToList();

                _logger.LogDebug("prepare rehydrate RU Cost {RequestCharge}", response.RequestCharge);
                var states = new Queue<StateIds>();
                stateIds.ToList().ForEach(states.Enqueue);

                while (states.Count > 0)
                {
                    overallCount = await RehydratePrepareByStateIdsInQueueAsync(rehydrateSettings.TakePerThrottle, states, overallCount);
                    if (states.Count > 0)
                        await Task.Delay(TimeSpan.FromMilliseconds(rehydrateSettings.ThrottleMs));
                }
            }

            _logger.LogInformation("Completed event source update records with RehydrateRequired as true from {startDate} to {endDate}, {OverallCount} records",
                startDate,
                endDate,
                overallCount);
        }
    }

    private async Task<int> RehydratePrepareByStateIdsInQueueAsync(int takePerThrottle, Queue<StateIds> states, int overallCount)
    {
        var tasks = new List<Task>();
        for (var i = 0; i < takePerThrottle; i++)
        {
            if (states.Count == 0)
                break;
            var state = states.Dequeue();
            tasks.Add(Task.Factory.StartNew(async () =>
            {
                try
                {
                    await RehydratePrepareAsync(state);
                }
                catch (Exception e)
                {
                    _logger.LogError(e, "Error patching RehydrateRequired on id {Id}", state.Id);
                }
            }));
            overallCount++;
        }

        await Task.WhenAll(tasks);
        return overallCount;
    }

    private async Task<int> RehydratePrepareAllInQueueAsync(int takePerThrottle, Queue<TState> states, int overallCount, bool markRehydrateRequiredAs = true)
    {
        var tasks = new List<Task>();
        for (var i = 0; i < takePerThrottle; i++)
        {
            if (states.Count == 0)
                break;
            var state = states.Dequeue();
            tasks.Add(Task.Factory.StartNew(async () =>
            {
                try
                {
                    await RehydratePrepareAsync(new StateIds(state.Id!, _getPartitionKeyService.Get(state)), markRehydrateRequiredAs);
                }
                catch (Exception e)
                {
                    _logger.LogError(e, "Error patching RehydrateRequired on id {Id}", state.Id);
                }
            }));
            overallCount++;
        }

        await Task.WhenAll(tasks);
        return overallCount;
    }

    public static void RegisterDependency(IServiceCollection services)
    {
        services.AddTransient<IPrepareEventSourceForRehydrate<TState>, PrepareEventSourceForRehydrateService<TState>>();
    }
}


using System.Text;
using evicore.eventsource.@base.interfaces;
using evicore.eventsource.@base.models;
using evicore.eventsource.cosmos.Model;
using evicore.gravity.common.Dtos;
using evicore.gravity.common.Interface;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using ucx.locking.@base.interfaces;
using ucx.locking.@base.models;

namespace evicore.eventsource.cosmos.services;

public class RehydrateEventSourceService<TState> : IRehydrateEventSource<TState> where TState : BaseState
{
    private readonly ICosmosDbService<EventSourceMessageRecord<TState>> _eventsCosmosDbService;
    private readonly ILockingService _lockingService;
    private readonly IEventSourceService<TState> _eventSourceService;
    private readonly LockOptions _lockOptions;
    private readonly ILogger<RehydrateEventSourceService<TState>> _logger;
    private readonly Dictionary<string, object> _scope;
    private readonly ICosmosDbService<TState> _stateCosmosDbService;

    public RehydrateEventSourceService(ILogger<RehydrateEventSourceService<TState>> logger, IEventSourceService<TState> eventSourceService,
        ICosmosDbService<TState> stateCosmosDbService, ICosmosDbService<EventSourceMessageRecord<TState>> eventsCosmosDbService, ILockingService lockingService,
        IOptions<LockOptions> options)
    {
        _logger = logger;
        _eventSourceService = eventSourceService;
        _eventsCosmosDbService = eventsCosmosDbService;
        _lockingService = lockingService;
        _stateCosmosDbService = stateCosmosDbService;
        _lockOptions = options.Value;
        _scope = new Dictionary<string, object>
        {
            { "Class", "RehydrateEventSourceService<TState>" }
        };
    }

    public async Task RehydrateAllAsync(string? settings = null)
    {
        var scope = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task RehydrateAllAsync(string? settings = null)" },
            { "RehydrateSettings", settings ?? string.Empty }
        };
        using (_logger.BeginScope(scope))
        {
            var rehydrateSettings = new RehydrateSettings();
            if (settings is not null) rehydrateSettings = JsonConvert.DeserializeObject<RehydrateSettings>(settings)!;

            _logger.LogInformation("Starting event source rehydrate all");
            var queryBuilder = new StringBuilder();
            queryBuilder.Append("SELECT c.id FROM c");
            if (rehydrateSettings.WhereRehydrateRequiredIsTrue)
                queryBuilder.Append(" WHERE c.rehydrateRequired = true");
            using var feed = _stateCosmosDbService.ReadItems<IdOnlyModel>(queryBuilder.ToString());
            var overallCount = 0;
            while (feed.HasMoreResults)
            {
                var stateIds = new Queue<string>();
                var response = await feed.ReadNextAsync();
                _logger.LogDebug("Rehydrate RU Cost {RequestCharge}", response.RequestCharge);
                response.ToList().ForEach(item => stateIds.Enqueue(item.id));
                while (stateIds.Count > 0)
                {
                    var tasks = new List<Task>();
                    for (var i = 0; i < rehydrateSettings.TakePerThrottle; i++)
                    {
                        if (stateIds.Count == 0)
                            break;
                        tasks.Add(RehydrateAsync(stateIds.Dequeue()));
                        overallCount++;
                    }

                    await Task.WhenAll(tasks);
                    if (stateIds.Count > 0)
                        await Task.Delay(TimeSpan.FromMilliseconds(rehydrateSettings.ThrottleMs));
                }
            }

            _logger.LogInformation("Completed event source rehydrate all with a count of {OverallCount}", overallCount);
        }
    }

    public async Task RehydrateAsync(string stateId)
    {
        var scopeDictionary = new Dictionary<string, object>(_scope)
        {
            { "Method", "Task RehydrateAsync(string stateId)" },
            { "StateId", stateId }
        };
        using (_logger.BeginScope(scopeDictionary))
        {
            _logger.LogInformation("Starting event source rehydrate single");
            var eventSourceMessages = (await _eventsCosmosDbService.ReadItemsByPartitionKey<EventSourceMessage>(stateId))?.ToList();
            if (eventSourceMessages is null || eventSourceMessages.Count == 0)
            {
                _logger.LogError("No eventSourceMessages found");
                return;
            }

            # region Distributed Lock

            await using (await _lockingService.LockAsync<TState>(stateId, _lockOptions, default))
            {
                var state = await _eventSourceService.RehydrateAsync(eventSourceMessages);
                await _stateCosmosDbService.UpsertItemAsync(state, eventSourceMessages.First().StateIds.PartitionKey);
            }

            # endregion

            _logger.LogInformation("Completed event source rehydrate single");
        }
    }

    public static void RegisterDependency(IServiceCollection services)
    {
        services.AddTransient<IRehydrateEventSource<TState>, RehydrateEventSourceService<TState>>();
    }
}



Thanks and Regards
Siraj

