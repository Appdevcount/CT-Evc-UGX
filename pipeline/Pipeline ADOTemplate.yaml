dotnet
swap-api-slots.yaml
parameters:
  - name: environment
    type: string
    values:
      - DV1
      - QA
      - IN1
      - PD1
  - name: serviceAccountName
    type: string
  - name: azureResourceGroup
    type: string

jobs:
  - deployment: Swap_Slots
    dependsOn: [Infrastructure]
    timeoutInMinutes: 300
    environment: ${{ lower(parameters.environment) }}
    displayName: Swap API Slots
    variables:
      apiWebAppName: $[ dependencies.Infrastructure.outputs['Infrastructure.terraformOutput.apiWebAppName'] ]
    strategy:
      runOnce:
        deploy:
          steps:
            - download: none
            - checkout: self
            - task: AzureAppServiceManage@0
              displayName: 'Swap API slots'
              name: SwapAPISlots
              inputs:
                 ConnectedServiceName: ${{ parameters.serviceAccountName }}
                 WebAppName: $(apiWebAppName)
                 ResourceGroupName: ${{ parameters.azureResourceGroup }}
                 SourceSlot: staging
                 SwapWithProduction: true


nuget-pack-and-deploy.yaml
parameters:
  - name: buildConfiguration
    type: string
  - name: projectPath
    type: string
  - name: publishFeed
    type: string
  - name: solutionPath
    type: string
  - name: nugetConfigPath
    type: string
  - name: dotnetVersion
    type: string
jobs:
  - job: PackAndPush
    timeoutInMinutes: 300
    displayName: "Nuget pack and push"
    steps:
      - download: none
      - checkout: self
      - task: UseDotNet@2
        displayName: 'Install .NET ${{ parameters.dotnetVersion }} SDK'
        inputs:
          packageType: 'sdk'
          version: ${{ parameters.dotnetVersion }}
          performMultiLevelLookup: true
      - task: DotNetCoreCLI@2
        displayName: dotnet restore
        inputs:
          command: 'restore'
          projects: ${{ parameters.solutionPath }}
          feedsToUse: 'config'
          nugetConfigPath: ${{ parameters.nugetConfigPath }}
      - task: DotNetCoreCLI@2
        displayName: "dotnet pack"
        inputs:
          command: 'pack'
          arguments: '--configuration ${{ parameters.buildConfiguration }}'
          packagesToPack: '${{ parameters.projectPath }}'
      - task: NuGetCommand@2
        displayName: 'nuget push'
        inputs:
          command: 'push'
          feedsToUse: 'select'
          packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg;$(Build.ArtifactStagingDirectory)/**/*.snupkg'
          nuGetFeedType: 'internal'
          publishVstsFeed: '${{ parameters.publishFeed }}'
          allowPackageConflicts: true
        

build-and-test.yaml
parameters:
  - name: dotnetVersion
    type: string
  - name: nugetConfigPath
    type: string
  - name: solutionPath
    type: string
  - name: testPath 
    type: string
    default: ''
  - name: dockerComposeFilePath
    type: string
    default: 'default'
jobs:
  - job:
    steps:
    - template: /dotnet/build-and-test-steps.yaml
      parameters:
        dotnetVersion: ${{ parameters.dotnetVersion }}
        nugetConfigPath: ${{ parameters.nugetConfigPath }}
        solutionPath: ${{ parameters.solutionPath }}
        dockerComposeFilePath: ${{ parameters.dockerComposeFilePath }}
        ${{ if eq(parameters.testPath, '' ) }}:
          testPath: ${{ parameters.solutionPath }}
        ${{ else }}:
          testPath: ${{ parameters.testPath }}

build-and-test-steps.yaml

parameters:
  - name: dotnetVersion
    type: string
  - name: nugetConfigPath
    type: string
  - name: solutionPath
    type: string
  - name: testPath 
    type: string
  - name: dockerComposeFilePath
    type: string
    default: 'default'
steps:
  - download: none
  - checkout: self
  - task: UseDotNet@2
    displayName: 'Install .NET ${{ parameters.dotnetVersion }} SDK'
    inputs:
      packageType: 'sdk'
      version: ${{ parameters.dotnetVersion }}
      performMultiLevelLookup: true
  - task: DotNetCoreCLI@2
    displayName: dotnet restore
    inputs:
      command: 'restore'
      projects: ${{ parameters.solutionPath }}
      feedsToUse: 'config'
      nugetConfigPath: ${{ parameters.nugetConfigPath }}
  - task: CmdLine@2
    condition: not(eq('${{ parameters.dockerComposeFilePath }}', 'default'))
    displayName: 'Docker Compose Up'
    inputs:
      script: 'docker-compose -f ${{ parameters.dockerComposeFilePath }} up -d'
  - task: DotNetCoreCLI@2
    displayName: dotnet test
    inputs:
      command: 'test'
      arguments: '${{ parameters.testPath }} --no-restore --collect "XPlat Code coverage"'
      publishTestResults: true
      testRunTitle: UnitTests
  - task: CmdLine@2
    condition: not(eq('${{ parameters.dockerComposeFilePath }}', 'default'))
    displayName: 'Docker Compose Down'
    inputs:
      script: 'docker-compose -f ${{ parameters.dockerComposeFilePath }} down'
  - task: PublishCodeCoverageResults@1
    displayName: 'Publish code coverage results'
    inputs:
      codeCoverageTool: 'Cobertura'
      summaryFileLocation: '$(Agent.TempDirectory)/**/*coverage.cobertura.xml'




update-appSettings-and-docker-tag.yaml
parameters:
  - name: serviceAccountName
    type: string
  - name: webAppResourceGroupName
    type: string
  - name: webAppName
    type: string
  - name: slotName
    type: string
    default: "staging"
    values:
      - "staging"
      - "production"
  - name: containerRegistry
    type: string
  - name: imageRepository
    type: string
  - name: imageTag
    type: string
    default: $(Build.BuildNumber)
  - name: jobTitle
    type: string
    default: "Update AppSettings and Docker Tag"
  - name: jobName
    type: string
    default: "azure_update_webapp"
  - name: environmentVariableFilePath
    type: string
  - name: swapSlot
    default: false
  - name: adoEnvironment
    type: string
    values:
      - DV1
      - QA
      - IN1
      - PD1
      - DEV
      - STAGE
      - PROD

jobs:
  - job: ${{ parameters.jobName }}
    displayName: ${{ parameters.jobTitle }}
    steps:
      - checkout: self
      - task: FileTransform@1
        displayName: "File transformation: appsettings.json"
        inputs:
          folderPath: "$(System.DefaultWorkingDirectory)"
          targetFiles: ${{ parameters.environmentVariableFilePath }}
          fileType: json

      - template: ../steps/create-appSettingJson-variable.yaml
        parameters:
          environmentVariableFilePath: ${{ parameters.environmentVariableFilePath }}

      - task: AzureWebAppContainer@1
        inputs:
          azureSubscription: ${{ parameters.serviceAccountName }}
          appName: ${{ parameters.webAppName }}
          containers: ${{ parameters.containerRegistry }}/${{ parameters.imageRepository }}:${{ parameters.imageTag }}
          ${{ if eq(parameters.slotName, 'staging') }}:
            deployToSlotOrASE: true
          ${{ else }}:
            deployToSlotOrASE: false
          resourceGroupName: ${{ parameters.webAppResourceGroupName }}
          slotName: ${{ parameters.slotName }}
          appSettings: $(appSettingString)

  - ${{ if eq(parameters.swapSlot, true) }}:
      - deployment: Swap_Slots
        dependsOn: ${{ parameters.jobName }}
        timeoutInMinutes: 300
        environment: ${{ parameters.adoEnvironment }}
        displayName: Swap Slots
        variables:
          apiWebAppName: ${{ parameters.webAppName }}
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - checkout: self
                - task: AzureAppServiceManage@0
                  displayName: "Swap slots"
                  name: SwapSlots
                  inputs:
                    ConnectedServiceName: ${{ parameters.serviceAccountName }}
                    WebAppName: ${{ parameters.webAppName }}
                    ResourceGroupName: ${{ parameters.webAppResourceGroupName }}
                    SourceSlot: staging
                    SwapWithProduction: true


Docker

docker-build-push.yaml
parameters:
  - name: dockerRegistry
    type: string
  - name: imageName
    type: string
  - name: dotnetVersion
    type: string
  - name: dockerFileLocation
    type: string
  - name: nugetConfigPath
    type: string
  - name: jobName
    type: string
    
 
jobs:
  - job: ${{ parameters.jobName }}
    timeoutInMinutes: 300
    displayName: Build and Publish Docker
    steps:
      - download: none
      - checkout: self
      - task: UseDotNet@2
        displayName: 'Install .NET ${{ parameters.dotnetVersion }} SDK'
        inputs:
          packageType: 'sdk'
          version: ${{ parameters.dotnetVersion }}
          performMultiLevelLookup: true
      - task: Docker@2
        displayName: 'Login to ACR'
        inputs:
          command: login
          containerRegistry: ${{ parameters.dockerRegistry }}
      - task: Docker@2
        displayName: 'Build image'
        inputs:
          containerRegistry: ${{ parameters.dockerRegistry }}
          repository: ${{ parameters.imageName }}
          command: 'build'
          Dockerfile: ${{ parameters.dockerFileLocation }}
          buildContext: '.'
          arguments: '--build-arg FEED_ACCESSTOKEN=$(System.AccessToken)'
          tags: |
            $(Build.BuildNumber)
            $(Build.SourceVersion)
            latest
      - task: Docker@2
        displayName: 'Push image'
        inputs:
          containerRegistry: ${{ parameters.dockerRegistry }}
          repository: ${{ parameters.imageName }}
          command: 'push'
          tags: |
            $(Build.BuildNumber)
            $(Build.SourceVersion)
            latest 



azure-pipeline-observer-and-api-deployment-template.yaml
parameters:
  - name: environment
    type: string
    values:
      - DV1
      - QA
      - IN1
      - PD1
  - name: servicePrincipal
    type: string
  - name: terraformStorageAccount
    type: string
  - name: resourceGroup
    type: string
  - name: terraformContainerName
    type: string
  - name: terraformStateFileName
    type: string
  - name: region
    type: string
    values:
      - eastus2
      - centralus
  - name: apiImageName
    type: string
  - name: observerImageName
    type: string
  - name: dockerRegistryName
    type: string
  - name: dockerRegistryUrl
    type: string
  - name: dockerRegistryRsg
    type: string
  - name: dockerRegistrySubscription
    type: string
  - name: terraformWorkingDirectory
    type: string
  - name: assetOwner
    type: string
  - name: businessOwner
    type: string
  - name: appName
    type: string
  - name: itSponsor
    type: string
  - name: deploymentResourceGroup
    type: string
    default: ''

jobs:
  - deployment: Infrastructure
    timeoutInMinutes: 300
    environment: ${{ parameters.environment }}
    displayName: Deploy Infrastructure
    variables:
      env: ${{ lower(parameters.environment) }}
      ${{ if eq(parameters.deploymentResourceGroup, '' ) }}:
        deploymentRsg: ${{ parameters.resourceGroup }}
      ${{ else }}:
        deploymentRsg: ${{ parameters.deploymentResourceGroup }}

    strategy:
      runOnce:
        deploy:
          steps:
            - download: none
            - checkout: self
            - task: AzureCLI@2
              displayName: 'Create Terraform state storage'
              inputs:
                azureSubscription: ${{ parameters.servicePrincipal }}
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  az storage account create --name ${{ parameters.terraformStorageAccount }} --resource-group $(deploymentRsg) --location ${{ parameters.region }} --sku Standard_LRS --allow-blob-public-access false --min-tls-version TLS1_2 --tags 'CostCenter=61700200' 'AssetOwner=${{ parameters.assetOwner }}' 'BusinessOwner=${{ parameters.businessOwner }}' 'DataClassification=Sensitive' 'AppName=${{ parameters.appName }} ' 'ITSponsor=${{ parameters.itSponsor }}' 'Tier=3'
                  az storage container create --name ${{ parameters.terraformContainerName }} --account-name ${{ parameters.terraformStorageAccount }}
                  STORAGE_ACCOUNT_KEY=$(az storage account keys list -n ${{ parameters.terraformStorageAccount }} | jq ".[0].value" -r)
                  echo "setting storage account key variable"
                  echo "##vso[task.setvariable variable=ARM_ACCESS_KEY;issecret=true]$STORAGE_ACCOUNT_KEY"

            - task: ms-devlabs.custom-terraform-tasks.custom-terraform-installer-task.TerraformInstaller@0
              displayName: "Install Terraform"
              inputs:
                terraformVersion: "latest"

            - powershell: |
                git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%20Modules'
                git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/Terraform%20Modules/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/Terraform%2520Modules'
                git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%20Platform'
                git config --global --add url."https://eviCoreDev:$(System.AccessToken)@dev.azure.com/eviCoreDev/eviCore%20Platform/_git".insteadOf 'ssh://git@ssh.dev.azure.com/v3/eviCoreDev/eviCore%2520Platform'
                git config --global -l
              displayName: Git url rewrite

            - task: TerraformTaskV2@2
              displayName: "Terraform init"
              inputs:
                provider: "azurerm"
                command: "init"
                workingDirectory: ${{ parameters.terraformWorkingDirectory }}
                backendServiceArm: ${{ parameters.servicePrincipal }}
                backendAzureRmResourceGroupName: $(deploymentRsg)
                backendAzureRmStorageAccountName: ${{ parameters.terraformStorageAccount }}
                backendAzureRmContainerName: ${{ parameters.terraformContainerName }}
                backendAzureRmKey: ${{ parameters.terraformStateFileName }}

            - task: TerraformTaskV2@2
              displayName: "Terraform plan"
              name: 'TerraformA'
              inputs:
                provider: "azurerm"
                command: "plan"
                workingDirectory: ${{ parameters.terraformWorkingDirectory }}
                commandOptions: '-var-file Environments/$(env).tfvars -var=resource_group_name="${{ parameters.resourceGroup }}" -var=container_image_version="$(Build.BuildNumber)" -var=observer_container_image_name="${{ parameters.observerImageName }}" -var=api_container_image_name="${{ parameters.apiImageName }}" -var=docker_registry_name="${{ parameters.dockerRegistryName }}" -var=docker_registry="${{ parameters.dockerRegistryUrl }}" -var=docker_registry_rsg=${{ parameters.dockerRegistryRsg }} -var=docker_registry_sub=${{ parameters.dockerRegistrySubscription }} -out=tfplan.out'
                environmentServiceNameAzureRM: ${{ parameters.servicePrincipal }}
            - task: TerraformTaskV2@2
              displayName: "Terraform Apply"
              name: 'TerraformApply'
              inputs:
                provider: "azurerm"
                command: "apply"
                workingDirectory: ${{ parameters.terraformWorkingDirectory }}
                commandOptions: 'tfplan.out'
                environmentServiceNameAzureRM: ${{ parameters.servicePrincipal }}

            - task: PowerShell@2
              displayName: 'Read terraform outputs'
              name: terraformOutput
              inputs:
                targetType: 'inline'
                script: |
                  $terraformOutput = Get-Content "$(TerraformApply.jsonOutputVariablesPath)" | ConvertFrom-Json
                  $terraformOutput | Get-Member -MemberType NoteProperty | % { $o = $terraformOutput.($_.Name); Write-Host "##vso[task.setvariable variable=$($_.Name);isoutput=true]$($o.value)" }
  - template: /dotnet/swap-api-slots.yaml
    parameters:
        environment: ${{ parameters.environment }}
        serviceAccountName : ${{ parameters.servicePrincipal }}
        azureResourceGroup: ${{ parameters.resourceGroup }}
  


KAFKA

acl-creationV2.yml
parameters:
  - name: resourceName
    type: string
  - name: user
    type: string
  - name: operation
    type: string
    values:
      - RO
      - RW
  - name: aclType
    type: string
    values:
      - TOPIC
      - GROUP
    default: TOPIC
  - name: endPoint
    type: string
    values:
      - DevEnterpriseKafkacicd-UCX
      - IntEnterpriseKafkacicd-UCX
      - ProdEnterpriseKafkacicd-UCX
  - name: newCluster
    type: boolean
    default: true
steps:
  - ${{ if eq(parameters.newCluster, true) }}:
      - task: SSH@0
        displayName: Setup ACL For ${{ parameters.aclType }} ${{ parameters.resourceName }}
        inputs:
          sshEndpoint: '${{ parameters.endPoint }}'
          runOptions: 'commands'
          commands: |
            /cicdscripts/acl.sh  "${{ parameters.user }}|${{ parameters.aclType }}|${{ parameters.resourceName }}|${{ parameters.operation }}" 2>&1;
          readyTimeout: '20000'
      - pwsh: |
          $msg = 'There were errors on Check Setup ACL For Resource task'
          echo $msg
          throw $msg
        displayName: 'Issue with ACL setup'
        condition: and(succeeded(), eq(variables['next_task'], 1))


topic-creationV3.yml
parameters:
  - name: topicName
    type: string
  - name: partitions
    type: number
  - name: msRetention
    displayName: retention in (ms)
    type: number
  - name: cleanupPolicy
    type: string
    values:
      - 'delete'
      - 'compact'
      - 'compact,delete'
    default: 'delete'
  - name: replication
    type: number
    default: 3
  - name: endPoint
    type: string
    values:
      - DevEnterpriseKafkacicd-UCX
      - IntEnterpriseKafkacicd-UCX
      - ProdEnterpriseKafkacicd-UCX
  - name: newCluster
    type: boolean
    default: true
jobs:
  - job:
    displayName: 'Create ${{ parameters.topicName }}'
    variables:
      - name: pool
        ${{ if ne(parameters.endPoint, 'ProdEnterpriseKafkacicd-UCX') }}:
          value: 'ubuntu-latest-nonprod'
        ${{ if eq(parameters.endPoint, 'ProdEnterpriseKafkacicd-UCX') }}:
          value: 'ubuntu-latest'
    
    pool:
      name: ${{ variables.pool }}
    steps:
      - ${{ if eq(parameters.newCluster, true) }}:
          - task: SSH@0
            displayName: 'Create/Update topic ${{ parameters.topicName }}'
            inputs:
              sshEndpoint: '${{ parameters.endPoint }}'
              runOptions: 'commands'
              commands: |
                /cicdscripts/create_topic.sh "${{ parameters.topicName }}|${{ parameters.partitions }}|${{ parameters.msRetention }}|${{ parameters.replication }}|${{ parameters.cleanupPolicy }}" 2>&1
              readyTimeout: '20000'
          - pwsh: |
              $msg = 'There were errors on Check Create/Update topic task'
              echo $msg
              throw $msg
            displayName: 'Issue with Create/Update topic'
            condition: and(succeeded(), eq(variables['next_task'], 1))

React 
pull-request.yaml
parameters:
  - name: workingDir
    type: string
  - name: editorConfigPathToCheck
    type: string
    default: '$(git ls-files)'
  - name: pathToChangeWorkingDir
    type: string
    default: 'default'
  - name: RunSonarQubeAnalysis
    type: boolean
    default: false
  - name: SonarQubeProjectKey
    type: string
    default : 'default'
  - name: SonarQubeProjectName
    type: string
    default : 'default'
  - name: CheckmarxProjectName
    type: string
    default: 'default'
  - name: CheckmarxServiceConnection
    type: string
    default: 'default'
  - name: CheckmarxFullTeamName
    type: string
    default: 'default'
  - name: CheckmarxProjectRepoUrl
    type: string
    default: 'default'
  - name: CheckmarxPointOfContactEmail
    type: string
    default: 'default'
  - name: RunCheckMarxAnalysis
    type: boolean
    default: false
 

jobs:
  - job: Test
    condition: or(eq(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.Reason'], 'Manual'))
    steps:
      - template: /react/react-test-steps.yaml
        parameters:
          workingDir: ${{ parameters.workingDir }}
  - job: EditorConfig
    steps:
      - template: /misc/editor-config-template.yml
        parameters:
          pathToCheck: ${{ parameters.editorConfigPathToCheck }}
          pathToChangeWorkingDir: ${{ parameters.pathToChangeWorkingDir }}

  - job: SonarQube
    condition: ${{ eq(parameters.RunSonarQubeAnalysis, true) }}
    displayName: 'Running: SonarQube Analysis'
    dependsOn: Test
    pool:
      name: 'eheu2pd1epvmss'
    steps:
      - template: /sonarqube/sonarqube-react.yaml
        parameters:
          SonarQubeProjectKey: ${{ parameters.SonarQubeProjectKey }}
          SonarQubeProjectName: ${{ parameters.SonarQubeProjectName }}
          workingDir : ${{ parameters.workingDir }}

  - ${{ if eq(parameters.RunCheckMarxAnalysis, true) }}:
    - job: CheckMarx
      displayName: 'Running: Checkmarx Analysis'
      dependsOn: Test
      pool:
        name: 'eheu2pd1epvmss'
      steps:
        - template: /checkmarx/checkmarx.yaml
          parameters:
            projectName:  ${{ parameters.CheckmarxProjectName }}
            serviceConnection: ${{ parameters.CheckmarxServiceConnection }}
            fullTeamName: ${{ parameters.CheckmarxFullTeamName }}
            projectRepoUrl: ${{ parameters.CheckmarxProjectRepoUrl }}
            pointOfContactEmail: ${{ parameters.CheckmarxPointOfContactEmail }}
            


deploy-micro-ui-template.yml
parameters:
  - name: apimBaseUrl
    type: string
  - name: appInsightsInstrumentationKey
    type: string
  - name: servicePrincipal
    type: string
  - name: storageAccount
    type: string
  - name: environment
    type: string
  - name: workingDir
    type: string
  - name: sourceBuildContent
    type: string
  - name: targetContainerName
    type: string
  - name: signalRHub
    type: string
    default: 'default'

jobs:
  - job: Package
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '16.x'
      - task: Npm@1
        displayName: 'npm install'
        inputs:
          command: 'install'
          workingDir: ${{ parameters.workingDir }}
      - task: Npm@1
        displayName: 'npm run build'
        inputs:
          command: 'custom'
          customCommand: 'run build'
          workingDir: ${{ parameters.workingDir }}
        env:
          REACT_APP_API_BASE_URL: ${{ parameters.apimBaseUrl }}
          REACT_APP_INSTRUMENTATION_KEY: ${{ parameters.appInsightsInstrumentationKey }}
          REACT_APP_SIGNALR_HUB: ${{ parameters.signalRHub }}
      - task: CopyFiles@2
        inputs:
          SourceFolder: '${{ parameters.workingDir }}'
          Contents: |
            ${{parameters.sourceBuildContent}}
          TargetFolder: '$(Build.ArtifactStagingDirectory)'
          OverWrite: true
      - task: PowerShell@2
        displayName: 'Generate version file'
        inputs:
          targetType: 'inline'
          script: |
            $json = '{
             "version": $(Build.BuildNumber)
            }'
            $json | Out-File version.json
          workingDirectory: '$(System.ArtifactsDirectory)/build'
          pwsh: true # For Linux
      - task: PublishBuildArtifacts@1
        inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)'
          ArtifactName: artifacts
  - deployment: Deploy
    environment: ${{ parameters.environment }}
    dependsOn: Package
    strategy:
      runOnce:
        deploy:
          steps:
            - download: none
            - task: DownloadBuildArtifacts@0
              inputs:
                buildType: 'current'
                downloadType: 'single'
                artifactName: 'artifacts'
                downloadPath: '$(System.ArtifactsDirectory)'
            - task: AzureFileCopy@4
              inputs:
                sourcePath: '$(System.ArtifactsDirectory)/artifacts/build/*.*'
                azureSubscription: ${{ parameters.servicePrincipal }}
                destination: 'AzureBlob'
                storage: ${{ parameters.storageAccount }}
                containerName: ${{ parameters.targetContainerName}}



react-test-steps.yaml
parameters:
  - name: workingDir
    type: string

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: '16.x'
  - task: Npm@1
    displayName: 'npm install'
    inputs:
      command: 'install'
      workingDir: ${{ parameters.workingDir }}
  - task: Npm@1
    displayName: 'npm run test'
    inputs:
      command: 'custom'
      customCommand: 'run test'
      workingDir: ${{ parameters.workingDir }}
  - task: PublishCodeCoverageResults@1
    inputs: 
      codeCoverageTool: Cobertura
      summaryFileLocation: '$(Agent.TempDirectory)/**/*coverage.cobertura.xml'
      reportDirectory: 'coverage'


react-test.yaml

parameters:
  - name: workingDir
    type: string

jobs:
  - job: Test
    steps:
    - template: react-test-steps.yaml
      parameters:
        workingDir: ${{ parameters.workingDir }}


SonarQube
parameters:
  - name: dotnetVersion
    type: string
  - name: SonarQubeProjectKey
    type: string
  - name: SonarQubeProjectName
    type: string
  - name: solutionPath
    type: string
  - name: nugetConfigPath
    type: string
  - name: testPath
    type: string
 
steps:
  - task: SonarQubePrepare@5
    displayName: 'Sonar Qube Prepare'
    continueOnError: true
    inputs:
      SonarQube: 'Cigna SonarQube Prod-UCX'
      scannerMode: 'MSBuild'
      projectKey: ${{ parameters.SonarQubeProjectKey }}
      projectName: ${{ parameters.SonarQubeProjectName }}
      extraProperties: |
        sonar.cs.opencover.reportsPaths=$(Build.SourcesDirectory)\coverage.opencover.xml
        sonar.cs.xunit.reportsPaths=$(Build.SourcesDirectory)**/*.trx
        sonar.exclusions=**/*.yml, **/*.yaml
        sonar.coverage.exclusions="**Tests*.cs"
  - task: UseDotNet@2
    displayName: 'Install .NET ${{ parameters.dotnetVersion }} SDK'
    inputs:
      packageType: 'sdk'
      version: ${{ parameters.dotnetVersion }}
      performMultiLevelLookup: true
  - task: DotNetCoreCLI@2
    displayName: 'Dotnet Restore'
    inputs:
      command: 'restore'
      feedsToUse: 'config'
      projects: ${{ parameters.solutionPath }}
      nugetConfigPath: ${{ parameters.nugetConfigPath }}
      externalFeedCredentials: 'epplatform'
  - task: DotNetCoreCLI@2
    displayName: 'Dotnet Test'
    inputs:
      command: 'test'
      arguments: '${{ parameters.testPath }} --no-restore --collect "Code Coverage"'
  - task: SonarQubeAnalyze@5
    continueOnError: true
  - task: SonarQubePublish@5
    inputs:
      pollingTimeoutSec: '300'
     

sonarqube-react.yaml

---
parameters:
  - name: SonarQubeProjectKey
    type: string
  - name: SonarQubeProjectName
    type: string
  - name: nugetConfigPath
    type: string
    default: default
  - name: workingDir
    type: string

steps:
  - task: Npm@1
    displayName: 'npm install'
    inputs:
      command: 'install'
      workingDir: ${{ parameters.workingDir }}
  - task: Npm@1
    displayName: 'npm run test'
    inputs:
      command: 'custom'
      customCommand: 'run test --coverage'
      workingDir: ${{ parameters.workingDir }}
  - task: PublishCodeCoverageResults@1
    inputs: 
      codeCoverageTool: Cobertura
      summaryFileLocation: ${{ parameters.workingDir }}/coverage/lcov.info
      reportDirectory: ${{ parameters.workingDir }}/coverage
  - task: SonarQubePrepare@5
    continueOnError: true
    inputs:
      SonarQube: 'Cigna SonarQube Prod-UCX'
      scannerMode: 'CLI'
      configMode: 'manual'
      cliprojectKey: ${{ parameters.SonarQubeProjectKey }}
      cliprojectName: ${{ parameters.SonarQubeProjectName }}
      extraProperties: |
        sonar.sources=${{ parameters.workingDir }}/src
                sonar.tests=${{ parameters.workingDir }}/src
                sonar.exclusions=${{ parameters.workingDir }}/src/index.tsx,${{ parameters.workingDir }}/src/**/*.ts
                sonar.test.inclusions=${{ parameters.workingDir }}/src/**/*.test.ts,${{ parameters.workingDir }}/src/**/*.test.tsx
                sonar.coverage.exclusions=${{ parameters.workingDir }}/src/index.tsx,${{ parameters.workingDir }}/src/**/*.ts
                sonar.javascript.lcov.reportPaths=${{ parameters.workingDir }}/coverage/lcov.info
                sonar.testExecutionReportPaths=${{ parameters.workingDir }}/coverage/test-report.xml
  - task: SonarQubeAnalyze@5
    continueOnError: true
  - task: SonarQubePublish@5
    inputs:
      pollingTimeoutSec: "300"


Checkmarx
parameters:
  - name: projectName
    type: string
  - name: serviceConnection
    type: string
  - name: fullTeamName
    type: string
  - name: projectRepoUrl
    type: string
  - name: pointOfContactEmail
    type: string

steps:
  - checkout: self
    persistCredentials: true
  #Preform checkmarx security scan
  - task: Application security testing@2022
    displayName: 'Checkmarx Security Scan'
    inputs:
      projectName: ${{ parameters.projectName }}
      enableProxy: false
      enableSastScan: true
      CheckmarxService: ${{ parameters.serviceConnection }}
      fullTeamName: ${{ parameters.fullTeamName }}
      folderExclusion: 'cvs, .svn, .hg , .git, .bzr, bin , obj,  backup, .idea, node_modules'
      fileExtension: '!**/*.DS_Store, !**/*.ipr, !**/*.iws, !**/*.bak, !**/*.tmp, !**/*.aac, !**/*.aif, !**/*.iff, !**/*.m3u, !**/*.mid, !**/*.mp3,!**/*.mpa, !**/*.ra, !**/*.wav, !**/*.wma, !**/*.3g2, !**/*.3gp, !**/*.asf, !**/*.asx, !**/*.avi,!**/*.flv, !**/*.mov, !**/*.mp4, !**/*.mpg,  !**/*.rm, !**/*.swf, !**/*.vob, !**/*.wmv, !**/*.bmp, !**/*.gif, !**/*.jpg, !**/*.png, !**/*.psd, !**/*.tif, !**/*.swf, !**/*.jar, !**/*.zip, !**/*.rar, !**/*.exe, !**/*.dll, !**/*.pdb, !**/*.7z, !**/*.gz, !**/*.tar.gz, !**/*.tar, !**/*.gz, !**/*.ahtm, !**/*.ahtml, !**/*.fhtml, !**/*.hdm, !**/*.hdml,   !**/*.hsql, !**/*.ht, !**/*.hta, !**/*.htc, !**/*.htd, !**/*.war, !**/*.ear, !**/*.htmls, !**/*.ihtml, !**/*.mht, !**/*.mhtm, !**/*.mhtml, !**/*.ssi, !**/*.stm, !**/*.stml, !**/*.ttml, !**/*.txn, !**/*.xhtm, !**/*.xhtml, !**/*.class, !**/*.iml'
      comment: '{ "repo_url": ${{ parameters.projectRepoUrl }}, "point_of_contact": ${{ parameters.pointOfContactEmail }} }'
      avoidDuplicateScans: true
      enableDependencyScan: false
  #Convert checkmarx report into variables
  - task: oneLuckiDevJson2Variable@1
    displayName: 'JSON to Variable'
    inputs:
      jsonFile: '$(Agent.BuildDirectory)\cxReport_$(Build.BuildNumber).json'
      shouldPrefixVariables: true
  #Add checkmarx comments to pull request    
  - checkout: ucxAdoTemplates
  - task: PowerShell@2
    condition: eq(variables['Build.Reason'], 'PullRequest')
    displayName: Adding checkmarx findings to PR
    inputs:
      targetType: filePath
      filePath: '$(Build.SourcesDirectory)/ucx-ado-templates/checkmarx/Checkmarx.PRComments.ps1'
      arguments: >
        -accessToken $(System.AccessToken)
        -highResults $(json.highResults)
        -mediumResults $(json.mediumResults)
        -lowResults $(json.lowResults)
        -sastScanResultsLink '$(json.sastScanResultsLink)'



Thanks and Regards
Siraj

